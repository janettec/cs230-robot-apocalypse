  call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
  zip together new_keys and keys, convert it to dictionary, assign it to m.
  derive the class DisallowedHost from the SuspiciousOperation base class.
  from django.middleware.csrf import get_token into default name space.
  substitute the '%s' with table and list containing key, respectively.   return default.
  if num is greater than self._max_entries,
  if for all attr in list of attributes 'level', 'msg', 'hint', 'obj' and 'id', self and other have the same attribute attr,
  call method __init__ from the base class of the class MemcachedCache with arguments: server, params,
  with call to the io.open function with fname and string 'rb' as arguments, renamed to f,
  return default.
  __locks is an empty dictionary.
  do nothing.
  if timeout is not None,
  substitute value_not_found_exception for self.LibraryValueNotFoundException.
  value under the 'debug' key of the context_extras dictionary is boolean True.
  define the method inner with argument check.
  call the method self._set with key, pickled and timeout as arguments.
  if not,
  remove file tmp_path.
  raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a get() method' as argument.
  with previous result and list containing cull_num, respectively as arguments.   call the method cursor.execute with string "DELETE FROM %s WHERE cache_key < %%s" as argument,
  if self.id exists, convert self.id to a string, surround it with round brackets, substitute id for it, otherwise id is an empty string.
  for every k and v in return value of the ret.items function,
  call the method self.incr_version with key, negative delta and version as arguments.
  errors is an empty list
  for every key and value in data.items method return value,
  call the function signals.request_finished.connect with argument cache.close.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  call the options.get method with string 'CULL_FREQUENCY' and integer 3 as arguments, use the string 'cull_frequency' and previous result as the arguments for the call to the params.get method, substitute the result for cull_frequency.
  messages is an instance of the ValidationError class created with an argument messages.
  from django.conf import settings into default name space.
  if exception OSError, renamed to e, is caught,
  call the self._createdir method.
  new_value is a sum of value and delta.
  try,
  import module errno.
  do nothing.
  alternatively, if six.PY3 is true check if message does not have an attribute 'message', if six.PY3 is false, check if message doesnt have an attribute 'code', perform the following,
  for every field, messages in return value of the message.items method,
  description is a string "An instance of the '%s' class" with '%s' replaced by value of receiver.__class__.__name__.
  define the function get_key_func with argument key_func.
  if ValueError or TypeError exceptions occurred,
  if ImportError, renamed to e, exception is caught,
  define the initialization method __init__ with arguments: self class instance, dir and params.
  define the method __iter__ with an argument self.
  if token is None,
  try,
  import pickle.
  substitute the datetime.max for exp.
  return default.
  call f.read function, use the result as the argument for zlib.decompress function call, call the pickle.loads function with the previous result as argument, return the result.
  define the method __init__ with argument self, server and params.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  call the function import_string with argument backend.
  call the __init__ method with self and params arguments from the base class BaseCache.
  derive class InvalidCacheBackendError from the ImproperlyConfigured base class.
  define the protected method _base_set with 4 arguments, self class instance, key, value and timeout set to DEFAULT_TIMEOUT.
  return default.
  from __future__ import unicode_literals into default name space.
  DEBUG is integer 10.
  call the function cache.close.
  derive the class BaseMemcachedCache from base class BaseMemcachedCacheMethods and BaseCache.
  from django.utils.synch import RWLock into default name space.
  if self._cull_frequency equals to integer 0.
  self.verbose_name_plural is a string 'cache entries'.
  return val.
  decorator register with argument Tags.compatibility.
  cache_suffix is a string '.djcache'.
  import module time.
  define the method _delete with arguments self and key.
  call the method now.replace with argument tzinfo set to None, substitute it for now.
  from itertools import chain into default name space.
  delete the value under the key key of self._cache dictionary.
  if delta is smaller than integer 0,
  substitute the '%s' with table and 3 elements of a list: b64encoded, exp and key, respectively.   if not,
  return errors.
  call the method self.validate_key with argument key.
  call the method self._cull.
  try,
  if new_errors is not an iterable object raise an error with error message "The function %r did not return a list. All functions registered with the checks registry must return a list.", with '%s' replaced by value of check.
  for every reference and receivers in return value of the call of obj.unresolved_references.items method,
  return boolean True.
  call the self.make_key with key and version set to version as arguments, substitute the result for key.
  return errors.
  if ValueError or TypeError exceptions occurred,
  define the function _check_boolean_field_default_value with app_config set to None and kwargs dictionary as arguments.
  call the BaseCache.__init__ method with self class instance and params as the arguments.
  substitute v for value under the k-th element of m key of _ dictionary.
  fetch one record from the database cursor points at, substitute the first element of return value for num.
  and expires is not an instance of datetime.   convert expires to a string, use it as argument for the call to the function typecast_timestamp, substitute the result for expires.
  define the function check_1_6_compatibility with argument kwargs dictionary.
  define the method __delattr__ with self and name as arguments.
  define the function default_key_func with 3 arguments, key, key_prefix and version.
  call the function local, substitute the result for self._caches.
  call the method self.make_key with key and version set to version as arguments, substitute it for key.
  self._cull_frequency is integer 3.
  call the timezone.now function, substitute the result for now.
  call the method self_cache.delete_multi with argument list containing keys mapped through function l.
  if KeyError exception is caught,
  call the __init__ method with 3 arguments: WARNING, unpacked list args and unpacked dictionary kwargs from the base class of Warning.
  ERROR is integer 40.
  do nothing.
  define the method _cull with argument self.
  call the function pickle.load with argument f, substitute the result for exp.
  call os.makedirs function with self._dir and hexadecimal 0o700 as arguments.
  call the function settings.is_overridden with argument string 'MANAGERS', if it evaluates to boolean True,
  define the method _set with 4 arguments, self class instance, key, value and timeout set to DEFAULT_TIMEOUT.
  from django.conf import settings into default name space.
  if self has an 'error_dict' attribute,
  substitute the '%s' with table and list containing first element of cursor.fetchone method, respectively.   define the method clear with argument self.
  substitute message.message, message.code, message.params for message, code and params, respectively.
  call the function get_token with an argument request, substitute the result for token.
  self.object_name is a string 'CacheEntry'.
  except if AttributeError is caught,
  from django.utils import timezone and six into default name space.
  if server is an instance of six.string_types,
  substitute hint for self.hint.
  define the method get with 5 arguments, self class instance, key, default set to None and version set to None.
  call the params.get method wit string 'VERSION' and integer 1 as arguments, substitute the result for self.version.
  return an empty list.
  if self._dir path doesnt exists,
  weight is an integer 0.
  return integer 0.
  if not,
  define the __getitem__ method with self and alias arguments.
  self.model_name is a string 'cacheentry'.
  "Django 1.7 changed the global defaults for the MIDDLEWARE_CLASSES. django.contrib.sessions.middleware.SessionMiddleware,   django.contrib.auth.middleware.AuthenticationMiddleware, and django.contrib.messages.middleware.MessageMiddleware were removed   from the defaults. If your project needs these middleware then you should configure this setting.", obj set to None, and   id set to a string '1_7.W001', put the result into a list and return it.   if not,
  define the function check_all_models with app_configs defaulting to None and unpacked dictionary kwargs as arguments.
  substitute settings.LANGUAGES for the value under the 'LANGUAGES' key of the context_extras dictionary.
  if ValueError or TypeError exceptions occurred,
  substitute list containing element self for self.error_list.
  return boolean True.
  define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  call the __init__ method from the base class of the class ValidationError with arguments message, code and params.
  raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a delete() method' as argument.
  raise an exception.
  call the function force_str with argument self.obj, substitute the result for obj.
  call the options.get method with string 'MAX_ENTRIES' and integer 300 as arguments, use the string 'max_entries' and previous result as the arguments for the call to the params.get method, substitute the result for max_entries.
  define delete method with self class instance, key and version set to None, as arguments.
  import module warnings.
  _meta is class Options class instance initialized with table argument.
  if delta is smaller than integer 0.
  derive the class DummyCache from the base class BaseCache.
  call the import_string with argument backend, substitute it for backend_cls.
  if DEFAULT_CACHE_ALIAS is not contained in settings.CACHES,
  define the function make_template_fragment_key with fragment_name and vary_on defaulting to None as arguments.
  from django.db.backends.utils import typecast_timestamp into default name space.
  return cache.
  call the method self.key_function with key, self.key_prefix and version as arguments, substitute the result for new_key.
  call the model.check method with unpacked dictionary kwargs for every model in return value of function apps.get_models,
  if ImportError exception is caught,
  divide num_entries by self._cull_frequency, convert the result to an integer, call the random.sample function with filelist and previous result as arguments, substitute the result for filelist.
  timeout is a integer -1.
  derive the class DisallowedRedirect from the SuspiciousOperation base class.
  do nothing.
  return context_extras.
  define the method tag_exists with self class instance and tag as arguments.
  self.app_label is a string 'django_cache'.
  docsring
  if e.errno does not equals to errno.ENOENT,
  call the method self._cache.set_multi with safe_data, self.get_backend_timeout(timeout) as arguments.
  substitute '%r' in string 'Cache key contains characters that will cause errors if used with memcached: %r' with key,
  evaluate the method self._cache.incr with key and negative delta as arguments, return the result.
  raise an ValueError exception with string "Key '%s' not found" as argument, substitute '%s' for key.
  from django.apps import apps into default name space.
  substitute CacheEntry for self.cache_model_class.
  call the self.validate_key method with argument key.
  import module hashlib.
  define private method __eq__ with self class instance and other as arguments.
  define the method clear with argument self.
  define the function close_caches with dictionary pair of elements kwargs as argument.
  for every error in self.error_list,
  if self.id is contained in settings.SILENCED_SYSTEM_CHECKS return boolean True, False otherwise.
  define the method message_dict with an argument self.
  call the function warnings.warn with string "'get_cache' is deprecated in favor of 'caches'.", RemovedInDjango19Warning,
  derive the class Error from base class CheckMessage.
  if result is true,
  from django.utils.functional import lazy into default name space.
  return ret.
  return boolean False.
  do nothing.
  define the method has_key with 3 arguments: self, key, and version set to None.
  substitute value under the backend key of settings.CACHES dictionary for conf.
  call the __init__ method with 3 arguments: ERROR, unpacked list args and unpacked dictionary kwargs from the base class of Error.
  if AttributeError exception is caught,
  call the method self.make_key Whit key and version set to version as arguments, substitute the result for key.
  define the method update_error_dict with arguments self and error_dict.
  substitute self.version for version.
  get attribute 'caches' from the self._caches if exists, otherwise get an empty dictionary, call the values method on the return value, return it.
  return an dictionary containing 1 entry: return value of the function _get_val for 'csrf_token'.
  for every key and value in data.items function return value,
  if string 'django.middleware.clickjacking.XFrameOptionsMiddleware' is not contained in settings.MIDDLEWARE_CLASSES set,
  substitute self.default_timeout for timeout.
  if not,
  self.proxy is boolean False.
  define the method add with 5 arguments: self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  import module django.core.checks.compatibility.django_1_6_0.
  substitute messages.error_list for the value under the field key of the self.error_dict dictionary.
  if e.errno is not equal to errno.EEXIST,
  call the method self.set with key, value, timeout and version as arguments.
  substitute _ for ret.
  substitute message for self.message.
  substitute table for self.db_table.
  substitute error.message for message.
  if self._dir file path does not exists,
  if num_entries is lesser than self._max_entries,
  return boolean False.
  get models.signals name attribute, store it in obj.
  call the function now.replace with microseconds set to integer 0, substitute the result for now.
  l is lambda function with argument x, that calls the method self.make_key with x and version set to version as arguments.
  substitute self.registered_checks for checks.
  if value under the DEFAULT_CACHE_ALIAS key of caches dictionary is not equal to other, return boolean True, otherwise return False.
  derive the class PyLibMCCache from BaseMemcachedCache base class.
  define the method _cache with argument self.
  call the self._cull method.
  settings.SITE_ID.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  from django.utils import six into default name space.
  call the function _check_test_runner with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.
  define the method set with 5 arguments: self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  call the method cursor.execute with string "DELETE FROM %s" as argument, substitute the '%s' with table.
  for name in attributes of models_signals object,
  derive class CheckMessage from object base class.
  define the function make_key with self class instance, key and version set to None as arguments.
  return nothing.
  call the function _create_cache with argument alias.
  derive the class CacheClass from the DatabaseCache base class.
  define the method _has_expired with self and key as arguments.
  define the method get_many with self class instance, keys and version defaulting to None as arguments.
  call the method self.validate_key with argument key.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  from django.utils.six.moves import cPickle as pickle into default name space.
  derive the class Tags with base class object.
  description is a string "The '%s' function" replaced by value of receiver.__name__.
  do nothing.
  substitute '%s' in TEMPLATE_FRAGMENT_KEY_TEMPLATE string with fragment_name and args.hexdigest(), respectively, return the result.
  append field to problem_fields list for every model in apps.get_models with argument kwargs dictionary, only if app_configs is None,
  define the method close with self and dictionary pairs of elements kwargs.
  from django.utils.six.moves import cPickle as pickle, into default namespace.
  if length of key is greater than MEMCACHE_MAX_KEY_LENGTH,
  call the method self._lib.Client with argument self._servers.
  define the method __contains__ with self and key as arguments.
  call the function warnings.warn with previous string and CacheKeyWarning as arguments.   define the method incr_version with 4 arguments, self, key, delta defaulting to integer 1 and version defaulting to None.
  try,
  call the pickle.dumps function with value and pickle.HIGHEST_PROTOCOL as arguments.
  call the self.set method with key, new_value and version set to version as arguments.
  from __future__ import unicode_literals into default name space.
  call the method self.make_key with key and version set to version as arguments, substitute it for key.
  return check.
  return an empty list.
  define the protected method _cull with self class instance, db, cursor and now as arguments.
  if ImportError, renamed to e, is caught,
  call the method self.make_key with key and version set to version as arguments, substitute it for key.
  from django.apps import apps into default name space.
  reuturn cache.
  call method __init__ with argument params from the base class of the FileBaseCache.
  call the method router.db_for_read with self.cache_model_class as argument, substitute the result for db.
  define the initialization method __init__ with self, table and params as arguments.
  try,
  call the self.delete method with key and version set to version as arguments.
  substitute library for self._lib.
  for every field, error_list in self.error_dict.items method return value,
  call the self._list_cache_files method, substitute the result for filelist.
  if key_function is callable object,
  call the method self._cache.decr with key and delta as arguments, substitute the result for val.
  call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
  define the method delete_many with 3 arguments: self, keys, and version set to None.
  call self.clear method.
  from django.core.cache.backends.base import InvalidCacheBackendError, CacheKeyWarning and BaseCache into default name space.
  from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
  call the self.get method with arguments key and version set to version, substitute the result for value.
  do nothing.
  return default_key_func.
  delete the value under key key of self._cache dictionary.
  call the function file_move_safe with tmp_path, fname, allow_overwrite set to boolean True as arguments.
  from django.utils.encoding import force_text into default name space.
  if val is not None,
  call the method self._base_set with string 'add', key, value and timeout as arguments, return the result.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  define the function _get_val.
  from django.utils.encoding import force_str into default name space.
  if self._cull_frequency equals to integer 0.
  extend the self.error_list list with message.error_list.
  call the translation.get_language_bidi function, substitute the result for the value under the 'LANGUAGE_BIDI' key of the context_extras dictionary.
  try,
  call the BaseCache initialization method __init__ with 3 arguments self, list of arguments args and dictionary of arguments kwargs.
  delete the value under key key of self._expire_info.
  call the Warning function with 3 arguments: hint tuple containing one string, Django 1.6 introduced a new default test runner.
  substitute the '%s' with table and list containing return value of the method call ops.value_to_db_datetime with argument now on the object under the db key of connections dictionary, respectively.   if exists return next entry from the database that cursor points at.
  call the self.get method with key and version set to version as arguments, return it if it is not None.
  call the self._lock.writer method, with the result perform the following,
  return string 'NOTPROVIDED'.
  derive the class BaseMemcachedCacheMethods from RenameMethodsBase the base class.
  derive the class SuspiciousMultipartForm from the SuspiciousOperation base class.
  decorator python_2_unicode_compatible.
  increment weight by integer 2.
  substitute value under the key key of self._cache dictionary for pickled.
  do nothing.
  if six.PY3 is true,
  try,
  call the function force_bytes with argument value, use the result as an argument for the call to the method base64.b64decode,
  from django.conf import settings into default name space.
  define the function _check_middleware_classes with app_config set to None and kwargs dictionary as arguments.
  remove 'LOCATION' key from kwargs dictionary and put it into location, or use an empty string if key doesnt exists.
  do nothing.
  import pylibmc.
  do nothing.
  if val is None,
  define the method _cache with self class instance as an argument.
  define the method __getattr__ with self and name as arguments.
  NON_FIELD_ERRORS is an string '__all__'.
  call the Error function with 4 arguments, string "%s was connected to the '%s' signal with a lazy reference to the '%s' sender,
  return an dictionary containing 1 entry: return value of the function timezone.get_current_timezone_name for 'TIME_ZONE'.
  define the method run_checks with self class instance, app_configs defaulting to None, tags defaulting to None as argument.
  docstirng
  call the method self.validate_key with argument key.
  try,
  call the params.get method with string 'KEY_PREFIX' and an empty string as arguments, substitute the result for self._key_prefix.
  It looks like this project was generated using Django 1.5 or earlier. You should ensure your tests are all running & behaving   as expected. See https://docs.djangoproject.com/en/dev/releases/1.6/#new-test-runner for more information.",   obj set to None and id set to a string '1_6.W001', put the result into a list and return it.   if not,
  do nothing.
  call the self._lib.Client with argument self._servers, substitute the result for self._client.
  on the object under the db key of connections dictionary call the method ops.value_to_db_datetime with argument exp, substitute the result for the exp.
  from django.utils.functional import cached_property into default name space.
  if level is not an integer raise an error with message string "The first argument should be level.".
  substitute server for self._servers.
  from __future__ import unicode_literals into default name space.
  derive DatabaseCache from the BaseDatabaseCache base class.
  try,
  do nothing.
  raise an EnvironmentError exception with string "Cache directory '%s' does not exist and could not be created" as argument,
  silent_variable_failure is an boolean True.
  call the method self._lib.Client with self._servers and pickleProtocol set to pickle.HIGHEST_PROTOCOL as arguments, substitute the result for self._client.
   from django.utils import timezone into default name space.
  if KeyError exception is caught,
  which has not been installed." with all the '%s' replaced by values of description, name and reference joined into a string delimited by '.', respectively,   obj set to receiver.__module__, hint set to None and id set to string 'signals.E001', append the result to errors.   return errors.
  try,
  self.error_list is an empty list.
  call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
  remove 'LOCATION' key from kwargs dictionary and put it into location, or use an empty string if key doesnt exists.
  derive the class SuspiciousOperation from the Exception base class.
  if key_func is not of None type,
  import module base64.
  if num is greater than self._max_entries,
  define the method clear with argument self.
  call the function params.update with argument kwargs.
  in the string "<%s: level=%r, msg=%r, hint=%r, obj=%r, id=%r>", replace '%s' with the name of the type of this class instance,
  delete the value under the key key of the self._expire_info dictionary.
  substitute registry.tag_exists for tag_exists.
  define initialization method __init__ with self class instance, level, msg, hint defaulting to None, obj defaulting to None and if defaulting to None as arguments.
  if check is not contained in self.registered_checks.
  if message is not an instance of the ValidationError class,
  call the method cursor.execute with string "DELETE FROM %s WHERE expires < %%s" as argument,
  import module tempfile.
  define the method get with 4 arguments, self class instance, key, default set to None and version set to None.
  call the operator.add on the values of the self object converted into a dictionary, until it is reduced to a single value, return it.
  from django.utils.encoding import smart_text into default name space.
  return boolean False.
  from threading import local into default name space.
  convert max_entries into a string, substitute it for self._max_entries.
  import module hashlib.
  define the initialization method __init__ with 3 arguments: self, name and params.
  call the method self.set with arguments key, value, timeout set to timeout, version set to version.
  call the function datetime.utcfromtimestamp with argument timeout, substitute it for exp.
  from .registry import register, run_checks, tag_exists and Tags into default name space.
  call the params.get with string 'OPTIONS' and empty dictionary as arguments, substitute the result for options.
  convert self to a list and return it.
  decorator register with argument Tags.compatibility.
  convert current_expires to a string, use it as the argument for the call to the function typecast_timestamp, substitute the result for current_expires.
  define the function check_1_7_compatibility with argument kwargs dictionary.
  library set to pylibmc and value_not_found_exception set to pylibmc.NotFound.   decorator cached_property,
  evaluate method self.has_key with key and version as arguments, if the result is true,
  substitute level for self.level.
  substitute obj for self.obj.
  import module django.core.checks.compatibility.django_1_7_0.
  define the method _cull with argument self.
  call the function self._key_to_file with key and version as arguments, substitute it for fname.
  do nothing.
  do nothing.
  if timeout equals to DEFAULT_TIMEOUT,
  call the _caches.setdefault method with name and empty dictionary as arguments, substitute the result for self_cache.
  derive the class MultipleObjectsReturned from the Exception base class.
  substitute value for the value under the key key of self._cache dictionary.
  if not,
  from __future__ import unicode_literals into default name space.
  return boolean False.
  MEMCACHE_MAX_KEY_LENGTH is integer 250.
  try,
  divide num by self._cull_frequency, floor the result and substitute it for cull_num.
  define the function static with an argument request.
  derive class BaseDatabaseCache from BaseCache base class.
  try,
  if not,
  if not,
  from django.utils import six into default name space.
  define the private method __contains__ with self class instance and key as arguments.
  define the method get_many with 3 arguments: self, keys, and version set to None.
  define the method has_key with self class instance, key and version defaulting to None as arguments.
  derive the class ViewDoesNotExist from the Exception base class.
  from django.utils.module_loading import import_string into default name space.
  call the method extend with an argument error_list on the return value of the method error_dict.setdefault called with 2 arguments: NON_FIELD_ERRORS and an empty list.
  call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
  signal is a string 'signals'
  if call to the _has_expired method with argument key evaluates to boolean False,
  if self object has an attribute '_client',
  call the method cursor.execute with string "SELECT cache_key FROM %s WHERE cache_key = %%s and expires > %%s" as argument,
  call the function datetime.fromtimestamp with argument timeout, substitute it for exp.
  aise and exception InvalidCacheBackendError with string "Could not find backend '%s': %s" as argument, replace '%s' with backend and e, respectively.
  if self.obj is None,
  if self has an 'error_dict' attribute,
  if ascii value of char is smaller than integer 33 or is equal to integer 127,
  convert return value of the function time.time to an integer, increment timeout by it.
  if message has an 'error_dict' attribute,
  call the exp.replace with microsecond set to integer 0, substitute the result for exp.
  from __future__ import unicode_literals into default name space.
  call the method self._cache.disconnect_all.
  evaluate the function backend_cls with location and params as arguments, return the result.
  call the method self._is_expired with argument f, invert the boolean result and return it.
  call the DefaultCacheProxy function, substitute it for cache.
  derive the class CheckRegistry with object as base class.
  substitute the second element of result for current_expires.
  call the params.get function with string 'OPTIONS' and None as arguments, substitute the result for self._options.
  renamed methods is a tuple containing 3 elements: '_get_memcache_timeout', 'get_backend_timeout' and RemovedInDjango19Warning.
  call the method now.replace with the argument microsecond set to integer 0, substitute the result for now.
  define the method incr with 4 arguments, self class instance, key, delta defaulting to integer 1 and version defaulting to None.
  call the initialization method with argument params for the base class of the BaseMemcachedCache class.
  define the function i18n with an argument request.
  define the method __setattr__ with self, name and value as arguments.
  __caches is an empty dictionary.
  call the self.get_backend_timeout with argument timeout, substitute it for the value under the key key of self._expire_info dictionary.
  define the method get with 5 arguments, self class instance, key, default set to None and version set to None.
  call the method self._delete with argument key.
  call the __init__ method with 3 arguments: CRITICAL, unpacked list args and unpacked dictionary kwargs from the base class of Critical.
  call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
  call the self.get method with key and version set to version as arguments, substitute the result for value.
  return an empty dictionary.
  call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
  define the method _is_expired with self and f as arguments.
  evaluate the self.has_key method with key as argument, return the result.
  define the method clear with argument self.
  call the self._createdir method.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  derive the class MemcachedCache from the BaseMemcachedCache base class.
  if fname file path exists,
  if value is None,
  import module time.
  from django.db import models into default name space.
  call the function os.remove with argument fname.
  if not,
  substitute pickled for value under the key key of self._cache dictionary.
  try,
  define the close method with 2 arguments, self and dictionary of argument pairs kwargs.
  increment weight by integer 2.
  if not,
  replace all the '%r' with self.level, self.msg, self.hint. self.obj and self.id, respectively, return the result.   define the method is_serious with argument self.
  call the self.incr method with key, negative delta and version set to version as arguments.
  define the method all with argument self.
  self.error_dict is an empty dictionary.
  import module operator.
  substitute the '%s' with table and 3 elements of a list: b64encoded, exp and key, respectively.   if DatabaseError exception is caught,
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  call the self._lock.writer method, with the result perform the following,
  if version is None,
  call the method cursor.execute with string "DELETE FROM %s WHERE cache_key = %%s" as argument,
  import module zlib.
  call the self._cache.get method with argument key, substitute the result for val.
  define the method tags_available with argument self.
  substitute the '%s' with table and list containing key, respectively.   define the method has_key with self class instance, key and version defaulting to None as arguments.
  call the function _check_boolean_field_default_value with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.
  substitute self._options for client.behaviors.
  if KeyError exception is caught,
  call the method self.make_key with key and version set to version as arguments, substitute it for key.
  define the method delete with self class instance, key and version defaulting to None as arguments.
  import pickle.
  define the method get with 4 arguments, self, key, default set to None and version set to None.
  if ret is true.
  import module os.
  property getter decorator,
  derive the class PermissionDenied from the Exception base class.
  call the method cursor.execute with string "INSERT INTO %s (cache_key, value, expires) VALUES (%%s, %%s, %%s)",
  define the get_many method with self class instance, keys and version set to None as arguments.
  if not,
  for every key in keys,
  if not,
  INFO is integer 20.
  call the _lock.setdefault method with name and RWLock() as arguments, substitute the result for self_lock.
  errors is an empty list.
  define the function check_model_signals with app_config defaulting to None and unpacked dictionary kwargs as arguments,
  get absolute directory path of dir, substitute it for self._dir.
  substitute '%s' with self._dir converted to a string.   define the method key_to_file with self class instance, key and version defaulting to None as arguments.
  substitute timeout for self.default_timeout.
  if not,
  call the method self.validate_key with key as argument.
  call the smart_text function with an argument token, return the result.
  do nothing.
  from django.db import models into default name space.
  return d.
  divide message by error.params, substitute the residue of the division for message.
  call the method tempfile.mkstemp with dir set to self._dir, substitute result for fd and tmp_path, respectively.
  models is a string 'models'
  call the method cursor.execute with string "SELECT COUNT(*) FROM %s" as argument, substitute the '%s' with table.
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  substitute the '%s' with table and list containing return value of the method call ops.value_to_db_datetime with argument now on the object under the db key of connections dictionary, respectively.   call the method cursor.execute with string "SELECT COUNT(*) FROM %s" as argument, substitute the '%s' with table.
  call the self.get method with k and version set to version as arguments, substitute the result for val.
  from django.db import connection into default name space.
  append check.tags into a list for every check in self.registered_checks if check has 'tags' attribute, put the elements into a set and return it.
  call the function pickle.dumps with argument value, use the result and integer -1 as arguments for the call to the function zlib.compress, use the result as an argument for the call to the f.write method.
  if messages is not an instance of the ValidationError class,
  define the method delete with self class instance, key and version set to None as arguments.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  if not,
  __all__ is a list containing next strings, 'CheckMessage', 'Debug', 'Info', 'Warning', 'Error', 'Critical',
  call the hashlib.md5 fuction with force_bytes(key) as argument.
  define private method __str__ with argument self.
  return boolean False.
  if row is None,
  evaluate the function import_string with key_func as argument, return the result.
  define the method decr with self, key, delta defaulting to integer 1 and version defaulting to None as arguments.
  call the self._delete method with argument f.name.
  raise an ValueError exception with string "Key '%s' not found" as argument, substitute '%s' with key converted into a string.
  if KeyError exception is caught,
  derive the class Warning from base class CheckMessage.
  return new_value.
  define method has_key with self class instance, key and version set to None as arguments.
  DEFAULT_TIMEOUT is a instance of the class object.
  return default.
  if value under the DEFAULT_CACHE_ALIAS key of caches dictionary equals to other, return boolean True, otherwise return False.
  call the method self._cache.set with key, value, self.get_backend_timeout(timeout) as arguments.
  define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
  do nothing.
  derive the class FieldError from the Exception base class.
  'CacheKeyWarning' and 'BaseCache'   DEFAULT_CACHE_ALIAS is a string 'default'.
  call the method self._cache.clear.
  finally perform,
  from django.utils.module_loading import import_string into default name space.
  evaluate the method connections[db].ops.cache_key_culling_sql, evaluate the result by table modulus, call the method cursor.execute,
  message is an instance of the ValidationError class created with an argument message.
  if message is an instance of dict type,
  if timeout is None,
  convert object self to a dictionary, return it.
  define the method set_many with self, data, timeout set to DEFAULT_TIMEOUT and version set to None as arguments.
  return context_extras.
  derive the class DjangoRuntimeWarning from the RuntimeWarning base class.
  if timeout equals to DEFAULT_TIMEOUT,
  return errors.
  call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
  else if timeout equals to integer 0,
  from django.core.files.move import file_move_safe into default name space.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  if OSError, renamed to e, exception is caught,
  raise an exception of class ValueError, with string "Key '%s' not found" as argument, where '%s' is substituted for key.
  if error.params is true,
  if pickled is not None.
  call the __init__ method with 3 arguments: DEBUG, unpacked list args and unpacked dictionary kwargs from the base class of Debug.
  call the function settings.is_overridden with argument string 'ADMINS', if it evaluates to boolean True,
  call the ops.quote_name method with argument self._table on the value under the db key of connections dictionary, substitute the result for table.
  vary_on is an empty tuple.
  append check to checks list, for every check in self.register_checks, if check has an attribute 'tags' and check.tags and tags set intersection is a non empty set.
  from django.db import connections, transaction, router and DatabaseError into default name space.
  with return value of the function io.open with fname and string 'rb' as arguments, named as f,
  call the delete method with key and version set to version as arguments.
  return default.
  settings.BASE_DIR.
  for every fname in filelist,
  return nothing.
  from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
  for every k in keys,
  derive the class AppRegistryNotReady from the Exception base class.
  substitute val for value under the k key of dictionary d.
  sum version and delta together, return the result.
  from __future__ import unicode_literals into default name space.
  define the method __ne__ with self and other as arguments.
  import module warnings.
  call the method cursor.execute with string "SELECT cache_key, expires FROM %s WHERE cache_key = %%s" as argument,
  if AttributeError exception is caught,
  derive the class MiddlewareNotUsed from the Exception base class.
  substitute message.error_dict for message.
  if val is None,
  return new_key.
  from . import Error, Tags and register into default name space.
  substitute None for pickled.
  if message is an instance of ValidationError class,
  call the method self.get_backend_timeout with argument timeout, substitute the result for timeout.
  call the function _check_middleware_classes with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.
  delete the value under the key key of self._cache dictionary.
  if features.needs_datetime_string_cast field of the object represented stored under the db key of connections dictionary is true,
  call close method on a file stream.
  return an dictionary containing 1 entry: request for 'request'.
  substitute table for self._table.
  if self equals to other return boolean False, otherwise return True.
  define the method decr with arguments self, key, delta defaulting to integer 1 and version defaulting to None.
  for every k in doomed,
  raise an exception NotImplementedError with string 'subclasses of BaseCache must provide a clear() method' as argument.
  set the attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary to value, return it.
  if ImportError exception occurred,
  evaluate the method self._has_expired with argument key, if it as False,
  call the function pickle.dumps with value and pickle.HIGHEST_PROTOCOL as the arguments, substitute the result for pickled.
  return nothing.
  if key if contained in value under the DEFAULT_CACHE_ALIAS key of caches dictionary, return boolean True, otherwise return False.
  self.verbose_name is a string 'cache entry'.
  call the __init__ method with 3 arguments: INFO, unpacked list args and unpacked dictionary kwargs from the base class of Info.
  call the method self._delete with argument k.
  self.abstract is boolean False.
  define the method __str__ with an argument self.
  call the function conf.copy, substitute it for params.
  define the method get with 4 arguments: self, key, default set to None and version set to None.
  except if KeyError exception is caught,
  self._max_entries is integer 300.
  define the method is_silence with argument self.
  d is an empty dictionary.
  substitute self.default_timeout for timeout.
  if self.hint exists, replace '%s' in a string "\n\tHINT: %s" with value of self.hint, substitute it for hint, otherwise hint is an empty string.
  do nothing.
  call the function self._key_to_file with key and version as arguments, substitute it for fname.
  for every fname in return value of the glob.glob1 function called with 2 arguments: self._dir and ,
  try,
  derive the class ObjectDoesNotExist from the Exception base class.
  substitute id for self.id.
  return val.
  substitute cache for value under the alias key of self._caches.caches dictionary.
  from django.utils import translation into default name space.
  define the method delete with 3 arguments: self, key, and version set to None.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  and stacklevel set to 2 as arguments.   call the _create_cache with backend and dictionary kwargs as arguments, substitute the result for cache.
  if not,
  if self._dir file path does not exists,
  from .. import Warning, register and Tags into default name space.
  call the function settings.is_overridden with argument string 'TEMPLATE_LOADERS', if it evaluates to boolean True,
  return self._client.
  call the Warning function with 4 arguments: string "MIDDLEWARE_CLASSES is not set.", hint tuple containing one string,
  derive the class Debug from base class CheckMessage.
  define the method __eq__ with self and other as arguments.
  call the self._lock.reader method, with the result perform the following,
  call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
  decorator register with Tags.models as an argument.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  for every cache in return value of the function caches.all.
  otherwise if message is an instance of the list type.
  if self has an 'error_dict' attribute,
  call the check function with argument app_config set to app_config, substitute the result for new_errors.
  call the method base64.b64encode with argument pickled, substitute the result for b64encoded.
  from django.utils.six.moves import cPickle as pickle into default name space.
  raise and exception InvalidCacheBackendError with string "Could not find backend '%s': %s" as argument, replace '%s' with backend and e, respectively.
  delete the attribute name from the cache dictionary under the DEFAULT_CACHE_ALIAS key.
  derive the class CacheClass from the base class FileBasedCache.
  define the method delete with self class instance, key and version defaulting to None as arguments.
  substitute msg for self.msg.
  CRITICAL is integer 50.
  raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a set() method' as argument.
  try,
  import module io.
  if timeouts is None return None, otherwise return the sum of function time.time return value and timeout.
  define the function debug with an argument request.
  define the method get_backend_timeout with self and timeout set to DEFAULT_TIMEOUT as arguments.
  fetch next entry for the database that cursor points into, substitute first element of it for num.
  import module glob.
  safe_data is an empty dictionary.
  define the method set_many with arguments, self, data, timeout defaulting to DEFAULT_TIMEOUT and version set to None.
  delete the value under the key key of self._expire_info dictionary.
  from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
  call the method self.validate_key with argument key.
  define the method __init__ with 4 arguments: self, message, code set to None and params set to None.
  define the function media with an argument request.
  from django.utils.encoding import force_bytes into default name space.
  evaluate the method self._cache.decr with key and negative delta as arguments, return the result.
  evaluate self._has_expired with argument key, if the result is True,
  define the function request with an argument request.
  derive the class CacheHandler from the object base class.
  do nothing.
  call the self._lock.writer method, with the result perform the following,
  derive the class DefaultCacheProxy from the base class object.
  return val.
  call the method b64encoded.decode with string 'latin1' as argument, substitute the result for b64encoded.
  obj is a string "?".
  if weight is greater or equal to integer 6,
  call the method self._cache.incr with key and delta as arguments, substitute the result for val.
  if e.errno equals to errno.ENOENT,
  define the initialization method __init__ with self class instance and table as arguments.
  call the timezone.now function, substitute the result for now.
  return boolean False.
  call the self._lock.writer method, with the result perform the following,
  from django.core.exceptions import ImproperlyConfigured and DjangoRuntimeWarning into default name space.
  call the function pickle.dumps with value and pickle.HIGHEST_PROTOCOL as the arguments, substitute the result for pickled.
  if mode equals to string 'add' and current_expires is lesser than now, or mode equals to string 'set', and result is true,
  define the function _create_cache with backend and dictionary pair of elements kwargs as arguments.
  define the method delete with self, key and version set to None as arguments.
  derive the class LocMemCache from the base class BaseCache.
  if renamed is boolean False,
  increment weight by integer 2.
  join into a string: md5 hash sum of force_bytes(key) and self.cache_suffix, compose root file path out of self._dir and previous result, return it.
  derive the class ValidationError from the Exception base class.
  define the method incr with self, key, delta defaulting to integer 1 and version defaulting to None as arguments.
  substitute code for self.code.
  for every i and k in enumerated values of self._cache, if i is divisible by self._cull_frequency, append k to doomed list.
  use the result as the argument for the function call to the pickle.loads, return the result.   define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  call the self._lock.reader method, with the result perform the following,
  define the function csrf with an argument request.
  for every message is message,
  only if app_configs is None ot model._meta.app_config is contained in app_configs, error is a list containing all the previous elements.   chain all errors elements into a list, return it.
  define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  or model._meta.app_config is contained in app_configs, for every field in model._meta.local_fields,  #ANNOTATION only if field is an instance of models.BooleanField and field.has_default() evaluates to False.    call the Warning function with 4 arguments: string "BooleanField does not have a default value.",
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  if fname is contained in self._list_cache_files method return value,
  call the self._lock.writer method, with the result perform the following,
  define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  from django.conf import settings into default name space.
  from django.utils import six into default name space.
  for every field, errors in self.error_dict.items method return value,
  self._caches.caches is an empty dictionary.
  return boolean False.
  if receiver is an instance of types.FunctionType type,
  define private method __repr__ with argument self.
  call the method self.validate_key with argument key.
  evaluate self._is_expired method with f as argument, if the result is false,
  import module random.
  if timeout is None,
  replace tags for check.tags.
  do nothing.
  evaluate self.clear method and return the result.
  substitute params for self.params.
  try,
  call the function lazy with arguments _get_val and six.text_type, substitute the result for _get_val.
  import module time.
  derive the class SuspiciousFileOperation from the SuspiciousOperation base class.
  define the method set with 5 arguments, self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  try,
  call the method make_key with arguments key and version from the base class of the class BaseMemcachedCache, use it as an argument for the call to the function force_str, return the result.
  call the function CheckRegistry, substitute the result for registry.
  define initialization method __init__ with argument self.
  import memcache.
  increment weight by integer 2.
  _ is an empty dictionary.
  from django.utils.encoding import force_bytes into default name space.
  import module types.
  call the method errors.extend with argument new_errors.
  context_extras is an empty dictionary.
  if settings.USE_TZ is true,
  call the method extend with an argument error_list on the return value of the method error_dict.setdefault called with 2 arguments: field and an empty list.
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  call the function signals.request_finished.connect with argument close_caches.
  self.cache_suffix converted to a string, appended to the character '*', call os.path.join with self._dir and fname as arguments,   filelist is a list containing all the previous results.   return filelist.
  try,
  self.registered_checks is an empty list.
  substitute registry.run_checks for run_checks.
  define the method make_key with self class instance, key and version defaulting to None as arguments.
  convert app and model._meta.object_name to strings, join them with separating '.' character, substitute it for obj.
  call the method self.registered_checks.append with argument check.
  if timeout is greater than integer 2592000,
  call the CacheHandler function, substitute the result for caches.
  from django.utils.itercompat import is_iterable into default name space.
  call the function self._key_to_file with key and version as arguments, substitute it for fname.
  from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
  call the method self.get with key and version set to version as arguments, substitute the result for value.
  num_entries is length of filelist.
  renamed is boolean False.
  if not.
  call method __init__ from the base class of the class PyLibMCCache with arguments: server, params,
  library set to memcache and value_not_found_exception set to ValueError.   property decorator,
  call the method self._cache_flush_all.
  errors is an empty list.
  call the function settings.is_overridden with argument string 'MIDDLEWARE_CLASSES', if the result is boolean False,
  define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
  get attribute 'error_dict' from the self object.
  call the method self.set with key, value, version incremented by delta, as arguments.
  define the __init__ method with argument self.
  call the translation.get_language function, substitute the result for the value under the 'LANGUAGE_CODE' key of the context_extras dictionary.
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  call the method self._base_set with string 'set', key, value and timeout as arguments.
  property getter decorator,
  return default.
  call the self._delete method with argument fname.
  if call to the settings.is_overridden with string 'TEST_RUNNER' evaluates to boolean False.
  call the function datetime.utcnow, substitute the result for now.
  derive the class CacheClass from the DummyCache base class.
  try,
  define the method validate_key with self class instance and key as arguments.
  call the _expire_info.setdefault method with name and empty dictionary as arguments, substitute the result for self_expire_info.
  call the method self._cache.delete with argument key.
  from __future__ import unicode_literals into default name space.
  call the method self.get_backend_timeout with argument timeout, substitute it for expiry.
  try,
  do nothing.
  if features.needs_datetime_string_cast field of object under the db key of connections dictionary is true and current_expires is not an instance of datetime object.
  if length of self._cache is greater or equal to self._max_entries,
  return an empty list.
  TEMPLATE_FRAGMENT_KEY_TEMPLATE is a string 'template.cache.%s.%s'.
  return an dictionary containing 1 entry: settings.MEDIA_URL for 'MEDIA_URL'.
  substitute message.error_list for message.
  errors is an empty list.
  call the method params.get with 2 arguments, string 'KEY_FUNCTION' and None, use the result as the argument for the call to the function get_key_func, substitute the result for the self.key_func.
  if self.LibraryValueNotFoundException exception is caught,
  derive the class ImproperlyConfigured from the Exception base class.
  if obj is instance of models.signals.ModelSignal class,
  define the method get_many with 3 arguments, self class instance, keys and version set to None.
  return new_value.
  return boolean True.
  raise an exception of the class ValueError with string "Key '%s' not found" as argument, '%s' is substituted for key.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  call the method cursor.execute with string "UPDATE %s SET value = %%s, expires = %%s WHERE cache_key = %%s" as argument,
  from django.utils.encoding import python_2_unicode_compatible and force_st into default name space.
  call the method self._cull with db, cursor and now as arguments.
  if tags is not None.
  call the method self._expire_info.clear.
  from django.core.exceptions import ImproperlyConfigured into default name space.
  from datetime import datetime into default name space.
  define the method set_many with 4 arguments: self, data, timeout set to DEFAULT_TIMEOUT and version set to None.
  if expires is lesser than now,
  with return value of the function io.open with fname and string 'rb' as arguments, named as f,
  from functools import reduce into default name space.
  return boolean True.
  split server with ';' as delimiter, substitute the result for self._servers.
  WARNING is integer 30.
  do nothing.
  timeout is a integer -1.
  __expire_info is an empty dictionary.
  raise an exception ImproperlyConfigured with string "You must define a '%s' cache" as argument, with '%s' replaced with DEFAULT_CACHE_ALIAS converted into a string.
  increment weight by integer 2.
  if self has an attribute 'error_dict',
  return inner.
  if self.LibraryValueNotFoundException exception is caught,
  define the method clear with argument self.
  substitute kwargs for params.
  define the method get_backend_timeout with self class instance and timeout set to DEFAULT_TIMEOUT as arguments,
  define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  define the messages with an argument self.
  call the method self.validate_key with argument key.
  otherwise is settings.USE_TI is true,
  otherwise if self.object is an instance of the models.base.ModelBase class,
  call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
  if alias is not contained in setting.CACHES,
  define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  from .. import Warning, register and Tags into default name space.
  yield field and ValidationError object converted to an list, created with an argument errors.
  derive the class Info from base class CheckMessage.
  call the method self.validate_key with argument key.
  property decorator,
  call the method self.validate_key with argument key.
  define the method _createdir with argument self.
  call the function datetime.now, substitute the result to now.
  define the method clear with self class instance as the argument,
  define the method _cache with argument self.
  convert key_prefix, version and key into strings, concatenate them respectively, with character ':' as delimiter, return the result.
  try,
  define initialization method __init__ with 4 arguments: self, host, list of arguments args and dictionary of arguments kwargs.
  from django.utils.http import urlquote into default name space.
  return boolean True.
  call the method ops.process_clob with second element of row as argument, on the object under the db key of connections dictionary, substitute the result for value.
  return value under the alias key of self._caches.caches dictionary.
  from itertools import chain into default name space.
  __all__ is an list containing 6 elements: 'get_cache', 'cache', 'DEFAULT_CACHE_ALIAS', 'InvalidCacheBackendError',
  from django.core import signals into default name space.
  add value and delta together, substitute the result for new_value.
  do nothing.
  if value is None,
  return self._client.
  call self._delete method with argument fname.
  substitute '%s' in string 'Cache key will cause errors if used with memcached: %s (longer than %s)' with key,
  call the method self._set with key, pickled and timeout as arguments.
  return error_dict.
  call the method self._cache.add with key, value, self.get_backend_timeout(timeout) as arguments.
  define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
  call the function self._key_to_file with key and version as arguments, use the result as an argument for the call to the self._delete method.
  derive the class FileBasedCache from BaseCache base class.
  val is None.
  from django.db import models into default name space.
  if not,
  for every check in checks,
  call the method self.validate_key with key as argument.
  self.managed is boolean True.
  call the self.clear method.
  call the method self.validate_key with argument key.
  return boolean True, otherwise return boolean False.   define private method __ne__ with self class instance and other as arguments.
  val is None.
  compatibility is a string 'compatibility'.
  define the method get with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  define the method register with self ans unpacked list tags as arguments.
  substitute registry.register for register.
  substitute value for value under the key key of safe_data dictionary.
  derive class Options from the base class object.
  if settings.DEBUG is true and value of the request.META dictionary under the 'REMOTE_ADDR' key is contained in settings.INTERNAL_IPS,
  call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
  define the method delete_many with arguments self, keys and version defaulting to None.
  call the self._lock.writer method, with the result perform the following,
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  try,
  substitute self.version for version.
  define the method _delete with self and fname as arguments.
  call the method cursor.execute with string "DELETE FROM %s WHERE cache_key = %%s" as argument,
  call the method pickle.dumps with value and pickle.HIGHEST_PROTOCOL as arguments, substitute it for pickled.
  evaluate pickle.loads with argument pickled, return the result.
  for every receiver, _ and _ in receivers,
  return key_func.
  call the method self.validate_key with argument key.
  substitute connection.queries for value under the 'debug' key of the context_extras dictionary.
  define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  return boolean False.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  if self._cull_frequency equals to integer 0.
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  convert timeout into an integer.
  from .messages import CheckMessage, Debug, Info, Warning, Error, Critical, DEBUG, INFO, WARNING, ERROR and CRITICAL into default name space.
  if val is None,
  call the method self.make_key with key and version set to version as arguments, substitute it for key.
  else if timeout converted into an integer equals to integer 0,
  define the method _list_cache_files with argument self.
  define the function delete_many with self, keys and version set to None as arguments.
  try,
  derive CacheEntry class from the object base class.
  derive the class Critical from base class CheckMessage.
  and MEMCACHE_MAX_KEY_LENGTH, call the function warnings.warn with previous string and CacheKeyWarning as arguments.   for every char in key,
  return boolean True.
  raise an ValueError exception with string "Key '%s' not found" as argument, substitute '%s' for key.
  remove 'BACKEND' key from params dictionary and put it into backend.
  from django.conf import settings into default name space.
  if fname file path exists,
  from django.utils.encoding import force_bytes into default name space.
  substitute the '%s' with table and list containing key, respectively.   call the cursor.fetchone method, substitute the result for row.
  define the method decr_version with 4 arguments, self, key, delta defaulting to integer 1 and version defaulting to None.
  define the initialization function __init__ with self class instance and params as arguments.
  try,
  from django.conf import settings into default name space.
  return boolean True if tag is contained in self.tags_available method return value, return False otherwise.
  replace all '%s' from string "%s: %s%s%s" with values of obj, id, self.msg and hint, respectively, return the result.
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  from django.utils.deprecation import RenameMethodsBase and RemovedInDjango19Warning into default name space.
  define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
  call the params.get method with string 'TIMEOUT' and integer 300 as arguments, use the string 'timeout' and previous result as the arguments for the call to the params.get method, substitute the result for timeout.
  convert timeout into an integer, return it.
  import module django.core.checks.model_checks.
  if fname doesnt start with self._dir and fname file path doesnt exists,
  if attribute '_client' of the self object is None,
  decorator register with Tags.models and Tags.signals as arguments.
  admin is a string 'admin'
  derive the class CacheClass from the base class LocMemCache.
  from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
  if IOError, renamed to e, exception is caught,
  substitute self.obj for model.
  define the method incr with self class instance, key, delta set to integer 1 and version set to None, as arguments.
  with return value of the function transaction.atomic with using set to db as arguments, perform the following,
  if not,
  define the function tz with an argument request.
  return client.
  import pickle.
  if vary_on is None,
  do nothing
  import module time.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  if pickle.PickleError exception is caught,
  call the method self._expire_info.get with key and integer -1 as arguments, substitute the result for exp.
  call the method cursor.execute with string "SELECT cache_key, value, expires FROM %s WHERE cache_key = %%s" as argument,
  define the function get_cache with backend and dictionary pair of elements kwargs as arguments.
  timeout is integer 300.
  define the method add with 5 arguments, self, key, value, timeout defaulting to DEFAULT_TIMEOUT and version defaulting to None.
  derive class CacheKeyWarning from the DjangoRuntimeWarning base class.
  if exp is None or exp is greater than the return value of the call to the function time.time,
  renamed is boolean True.
  do nothing.
  do nothing.
  call the method self.validate_key with argument key.
  raise and exception InvalidCacheBackendError with string "Could not find config for '%s' in settings.CACHES" as argument, replace '%s' with alias.
  if ImportError exception is caught,
  if version is None,
  increment weight by integer 2.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  call the method self.validate_key with argument key.
  if self._options exists,
  substitute the '%s' with table and list containing key, respectively.   fetch one entry from the database that cursor points at, substitute it for the result.
  if KeyError exception is caught,
  return an dictionary containing 1 entry: settings.STATIC_URL for 'STATIC_URL'.
  define the method __init__ with, self, server, params, library, value_not_found_exception as arguments.
  call the function pickle.dumps with expiry and integer -1 as arguments, use the result as the argument for the call to f.write function.
  return the printable representation of the self object converted to a dictionary.
  raise an exception of class NotImplementedError with string 'subclasses of BaseCache must provide an add() method' as argument.
  define the method __init__ with self, server and params as arguments.
  substitute model._meta.app_label for app.
  context_extras is an empty dictionary.
  do nothing.
  return boolean True.
  substitute third element of row list for expires.
  do nothing.
  call the force_text with an argument message, yield the result.
  define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
  import module pickle.
  define the function _check_test_runner with app_config set to None and kwargs dictionary as arguments.
  call the function urlquote with argument var for every var in vary_on, join the results into a string separated by ':', substitute it for key.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  do nothing.
  if value is None,
  if exp is not None and exp is lesser than return value of the function time.time,
  call the method self.validate_key with argument key.
  derive the class BaseCache from the object base class.
  from __future__ import unicode_literals into default name space.
  define the method has_key with self class instance, key and version defaulting to None as arguments.
  define the method get with 4 arguments, self class instance, key, default set to None and version set to None.
  from __future__ import unicode_literals into default name space.
  get attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary, return it.
  do nothing.
  call the method self._cache.get_multi with argument new_keys, substitute the result for ret.
  return boolean True if self.level is greater than or equals to ERROR, otherwise return boolean False.
  convert cull_frequency into an integer and substitute it for self._cull_frequency.
