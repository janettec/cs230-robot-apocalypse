  call the function BytesIO, substitute the result for self.file.
  if not,
  call the params.get method with string 'TIMEOUT' and integer 300 as arguments, use the string 'timeout' and previous result as the arguments for the call to the params.get method, substitute the result for timeout.
  do nothing.
  call the method tempfile.mkstemp with dir set to self._dir, substitute result for fd and tmp_path, respectively.
  define the method __init__ with 5 arguments: self, location set to None, base_url set to None, file_permissions_mode set to None,
  remove 'BACKEND' key from params dictionary and put it into backend.
  define the method __repr__ with an argument self.
  yield one element from the buffer_ iterable.
  endless loop,
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  call the CacheHandler function, substitute the result for caches.
  call the method __init__ from the base class of the InMemoryUploadedFile base class, with 6 arguments: file, name, content_type,
  evaluate pickle.loads with argument pickled, return the result.
  call the function middleware_method with the request and response as the arguments, assign the result to response.
  define the method _save with arguments self, name and content.
  call the self.get method with key and version set to version as arguments, return it if it is not None.
  convert ret to a boolean, return it.
  from django.conf import settings into default name space.
  call the os.remove function with argument name.
  from django.utils.six.moves import cPickle as pickle into default name space.
  return default.
  return boolean True.
  do nothing.
  raise and exception InvalidCacheBackendError with string "Could not find backend '%s': %s" as argument, replace '%s' with backend and e, respectively.
  substitute file_name for self.file_name.
  if self.obj is None,
  NON_FIELD_ERRORS is an string '__all__'.
  return errors.
  from django.utils.encoding import python_2_unicode_compatible into default name space.
  if content_length is greater than settings.FILE_UPLOAD_MAX_MEMORY_SIZE,
  from io import BytesIO into default name space.
  from django.core.exceptions import ImproperlyConfigured and DjangoRuntimeWarning into default name space.
  define the method __str__ with an argument self.
  define the method __exit__ with self, exc_type, exc_value and tb as arguments.
  substitute self._options for client.behaviors.
  import module itertools.
  call the smart_text function with an argument token, return the result.
  if directory is not an directory,
  call the function self.path with argument name, use the result as an argument for the call to the function os.path.getctime,
  return boolean True.
  read chunk_size bytes from file and store it in data.
  return self._size.
  call self._delete method with argument fname.
  call the urljoin function with arguments: self.base_url and result of the call to the function filepath_to_uri with argument name, return the result.
  call the method self.path with argument name, substitute the result for full_path.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  substitute '%s' in 'Forbidden (Permission denied): %s' with request.path, extra is an dictionary with two pairs of elements,
  call the function self._key_to_file with key and version as arguments, substitute it for fname.
  substitute self.version for version.
  call the self.path with argument name, substitute it for name.
  define the method _get_size_from_underlying_file with argument self.
  try,
  derive the class MultipleObjectsReturned from the Exception base class.
  do nothing.
  define the function lock with arguments f and flags.
  open the file self.name in mode or self.mode mode, whichever exists, assign the file handler to self.file.
  substitute obj for self.obj.
  import module os.
  call the function datetime.now, substitute the result to now.
  return new_key.
  try,
  self.registered_checks is an empty list.
  substitute the '%s' with table and list containing key, respectively.   define the method has_key with self class instance, key and version defaulting to None as arguments.
  call the function self.path with argument name, use it and mode as arguments for the call to the function open, use it as an argument for creatinon of a File object instance, return it.
  try,
  if delta is smaller than integer 0.
  raise an EnvironmentError exception with string "Cache directory '%s' does not exist and could not be created" as argument,
  if not,
  raise an exception.
  call the function local, substitute the result for self._caches.
  if value is None,
  DEBUG is integer 10.
  convert max_entries into a string, substitute it for self._max_entries.
  from django.utils.encoding import force_str into default name space.
  return default.
  if self.file is false or self.file.closed is true, return boolean true, otherwise return boolean false.
  call self.clear method.
  renamed is boolean True.
  define the method from_dict with argument cls and file_dict.
  call the function reraise from the module six, with list of arguments exec_info.
  substitute BytesIO for stream_class.
  do nothing.
  try,
  call the function debug.technical_404_response with request and e as arguments, assign the result to response.
  call the os.umask function with argument integer 0, substitute the result for old_umask.
  try,
  call the delete method with key and version set to version as arguments.
  exception_middleware is an empty list.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  call the __init__ method with 3 arguments: ERROR, unpacked list args and unpacked dictionary kwargs from the base class of Error.
  define the method chunks with arguments self ad chunk_size set to None.
  if an exception occurred,
  from django.utils.functional import cached_property into default name space.
  endless loop,
  substitute third element of row list for expires.
  from django.middleware.csrf import get_token into default name space.
  self.object_name is a string 'CacheEntry'.
  from django.utils.deprecation import RenameMethodsBase and RemovedInDjango19Warning into default name space.
  if mw_instance has an attribute named 'process_exception'.
  do nothing.
  substitute field_name for self.field_name.
  if OSError, renamed to e, is caught,
  if fname file path exists,
  define the function csrf with an argument request.
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  define the method __ne__ with self and other as arguments.
  call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
  for every field, errors in self.error_dict.items method return value,
  if message is not an instance of the ValidationError class,
  from django.utils.encoding import force_text into default name space.
  import module types.
  substitute charset for self.charset.
  if not.
  define the method get with 4 arguments, self, key, default set to None and version set to None.
  position the file self.file pointer at the end.
  increment weight by integer 2.
  replace '%s' in the string  "%s.process_template_response didn't return an HttpResponse object. It returned None instead.",
  define the method __contains__ with self and key as arguments.
  return boolean False.
  for every middleware_method in self._request_middleware,
  derive the class Tags with base class object.
  call the function os.chmod with arguments full_path and self.file_permissions_mode.
  return self.file.
  substitute os.unlink for unlink.
  increment weight by integer 2.
  define the method has_key with self class instance, key and version defaulting to None as arguments.
  derive the class Storage from the object base class.
  define the protected method _base_set with 4 arguments, self class instance, key, value and timeout set to DEFAULT_TIMEOUT.
  if os has an attribute 'utime',
  call to the self.handle_uncaught_exception method with request, resolver and value of the evaluated function sys.exec_info,
  derive the class File from the FileProxyMixin base class.
  substitute self._request_middleware for request_middleware.
  return boolean False.
  derive the class ImproperlyConfigured from the Exception base class.
  fetch next entry for the database that cursor points into, substitute first element of it for num.
  define the method set with 5 arguments: self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  substitute BOOL for LockFileEx.restype.
  return the printable representation of the self object converted to a dictionary.
  library set to pylibmc and value_not_found_exception set to pylibmc.NotFound.   decorator cached_property,
  substitute the '%s' in the string "The view %s.%s didn't return an HttpResponse object. It returned None instead.",
  try,
  derive the class DisallowedHost from the SuspiciousOperation base class.
  from __future__ import unicode_literals into default name space.
  call the function _create_cache with argument alias.
  call the hashlib.md5 fuction with force_bytes(key) as argument.
  call method __init__ with argument params from the base class of the FileBaseCache.
  call the method now.replace with the argument microsecond set to integer 0, substitute the result for now.
  call the self.delete method with key and version set to version as arguments.
  define the method __getattr__ with self and name as arguments.
  call the method self._base_set with string 'set', key, value and timeout as arguments.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  insert mw_instance.process_response at the beginning of self._response_middleware.
  raise an exception.
  call the function settings.is_overridden with argument string 'MANAGERS', if it evaluates to boolean True,
  self.abstract is boolean False.
  from django.conf import settings into default name space.
  convert object self to a dictionary, return it.
  substitute registry.run_checks for run_checks.
  evaluate the function smart_text with argument self.name, if exists, or an empty string, if not, return the result.
  substitute table for self._table.
  call the function get_token with an argument request, substitute the result for token.
  read chunk_size bytes from the old_file file, substitute the result for current_chunk.
  if response is True,
  for every func in self.response_fixes,
  signal is a string 'signals'
  define the function check_1_6_compatibility with argument kwargs dictionary.
  decorator register with argument Tags.compatibility.
  return iterator object based on the self.file collection object.
  otherwise is settings.USE_TI is true,
  call the method extend with an argument error_list on the return value of the method error_dict.setdefault called with 2 arguments: NON_FIELD_ERRORS and an empty list.
  call the method ops.process_clob with second element of row as argument, on the object under the db key of connections dictionary, substitute the result for value.
  do nothing.
  do nothing.
  self._max_entries is integer 300.
  define the method _cache with argument self.
  define the method created_time with arguments self and name.
  call the method self.validate_key with argument key.
  from django.conf import settings into default name space.
  get attribute 'error_dict' from the self object.
  define lambda function that returns self.file.seek field, use it as an argument for property function, put the result in seek.
  define lambda function that returns self.file.xreadlines field, use it as an argument for property function, put the result in xreadlines.
  return string 'NOTPROVIDED'.
  substitute server for self._servers.
  from django.utils.module_loading import import_string into default name space.
  call the initialization method with argument params for the base class of the BaseMemcachedCache class.
  substitute registry.tag_exists for tag_exists.
  if mw_instance has an attribute named 'process_template_response'.
  define the method _delete with self and fname as arguments.
  do nothig.
  errors is an empty list.
  call the method self.get_exception_response with request, resolver and integer 404 as the arguments, assign the result to response.
  if timeout equals to DEFAULT_TIMEOUT,
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  derive the class Debug from base class CheckMessage.
  for every line in chunk_buffer,
  return directories and files.
  return name.
  return default_key_func.
  try,
  define lambda function that returns self.file.fileno field, use it as an argument for property function, put the result in fileno.
  if token is None,
  return self._client.
  do nothing.
  second contains: string 'InternalHigh and ULONG_PTR, third: '_offset_union' and _OFFSET_UNION, forth 'hEvent' and HANDLE.   call the function POINTER with argument OVERLAPPED, substitute the result for LPOVERLAPPED.
  if e.errno is not equal to errno.EEXIST,
  initialize the object of a InMemoryUploadedFile class with arguments: file set to self.file, field_name set to self.field_name,
  if callback is of instance types.FunctionType,
  import module logging.
  call the _lock.setdefault method with name and RWLock() as arguments, substitute the result for self_lock.
  define the method __len__ with argument self.
  call the __init__ method with 3 arguments: WARNING, unpacked list args and unpacked dictionary kwargs from the base class of Warning.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  call the middleware_method with request, callback, callback_args and callback_kwargs as the arguments, substitute the result for response.
  call the self.get_backend_timeout with argument timeout, substitute it for the value under the key key of self._expire_info dictionary.
  substitute '%s' in string "%s_%s%s" with: file_root, next(count) and file_ext, join the dir_name and previous string into a valid file path, substitute it for name.
  otherwise if any other exception is caught,
  import module types.
  call to the self.handle_uncaught_exception method with request, resolver and value of the evaluated function sys.exec_info,
  define the method delete with 3 arguments: self, key, and version set to None.
  call the __init__ method with 3 arguments: CRITICAL, unpacked list args and unpacked dictionary kwargs from the base class of Critical.
  if vary_on is None,
  from ctypes import sizeof, c_ulong, c_void_p, c_int64, Structure, Union, POINTER, windll and byref into default name space.
  return response
  return self._size.
  call the method base64.b64encode with argument pickled, substitute the result for b64encoded.
  bring integer 2 to the power of 10, multiply it by integer 64, substitute the result for DEFAULT_CHUNK_SIZE.
  try,
  define the method __init__ with 4 arguments: self, name, content and content_type defaulting to a string 'text/plain'.
  alternatively, if six.PY3 is true check if message does not have an attribute 'message', if six.PY3 is false, check if message doesnt have an attribute 'code', perform the following,
  call the file.__enter__ method on self.
  call the method self.validate_key with argument key.
  import pylibmc.
  if attribute 'winerror' of object e is not equal to integer 32 and if 'errno' attribute is not equal to integer 13,
  derive the class CacheClass from the base class FileBasedCache.
  for every chunk in content.chunks function return value,
  call the method self._cull with db, cursor and now as arguments.
  if row is None,
  call the function middleware_method with request and response as the arguments, substitute the result for response.
  if e.errno is not equal to errno.EEXIST,
  evaluate the method self._cache.incr with key and negative delta as arguments, return the result.
  raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a modified_time() method'.
  call the self._delete method with argument f.name.
  call the middleware_method with the request as an argument, substitute the result for response.
  sum version and delta together, return the result.
  define method __init__ with self class instance, mode string 'w+b', bufsize set to integer -1, suffix and prefix set to empty strig,
  call the function warnings.warn with previous string and CacheKeyWarning as arguments.   define the method incr_version with 4 arguments, self, key, delta defaulting to integer 1 and version defaulting to None.
  call the self._lib.Client with argument self._servers, substitute the result for self._client.
  for every middleware_method in self._response_middleware,
  call the OVERLAPPED function, substitute the result for overlapped.
  return ret.
  try,
  from .. import Warning, register and Tags into default name space.
  assign the values to the callback, callback_args, callback_kwargs, respectively, from the resolver_match tuple.
  from django.utils.synch import RWLock into default name space.
  call the os.path.split with argument name, assign the result to the dir_name and file_name respectively.
  substitute '%s' in 'Not Found: %s' with request.path, extra is an dictionary with two pairs of elements 'status_code' with value 404,
  if call to the _has_expired method with argument key evaluates to boolean False,
  raise an exception NotImplementedError with string 'subclasses of BaseCache must provide a clear() method' as argument.
  substitute self.closed for close.
  raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a created_time() method'.
  call the method self.validate_key with argument key.
  substitute table for self.db_table.
  call the method self._cache.set with key, value, self.get_backend_timeout(timeout) as arguments.
  DEFAULT_TIMEOUT is a instance of the class object.
  if mw_instance has an attribute named 'process_request'.
  return nothing.
  get the position of the file self.file pointer, substitute it for size.
  from __future__ import unicode_literals into default name space.
  try,
  from django.core.files import temp as tempfile into default name space.
  try,
  call the function self.path with argument name, use the result as an argument for the call to the function os.path.getatime,
  call the function urlquote with argument var for every var in vary_on, join the results into a string separated by ':', substitute it for key.
  define lambda function that returns self.file.readinto field, use it as an argument for property function, put the result in readinto.
  return inner.
  call the method self_cache.delete_multi with argument list containing keys mapped through function l.
  return the second element of the return value of the call to the self._det_image_dimensions method.
  for every k in keys,
  do nothing.
  decorator python_2_unicode_compatible,
  for every k in doomed,
  add value and delta together, substitute the result for new_value.
  if AttributeError exception is caught,
  insert mw_instance.process_exception at the beginning of self._exception_middleware.
  if content has an attribute 'temporary_file_path',
  if data is empty.
  docstirng
  return boolean True.
  if e.errno is not equal to errno.ENOENT,
  raise an NotImplementedError with argument string 'subclasses of FileUploadHandler must provide a file_complete() method'.
  if timeout is not None,
  import module django.core.checks.model_checks.
  divide message by error.params, substitute the residue of the division for message.
  substitute '%s' from string "<%s: %s (%s)>" with self.__class__.__name__, self.name and self.content_type, respectively, use it as an argument for the call to the function force_str, return the result.
  call the self._list_cache_files method, substitute the result for filelist.
  from django.utils.encoding import force_bytes into default name space.
  if self.id exists, convert self.id to a string, surround it with round brackets, substitute id for it, otherwise id is an empty string.
  substitute size for self._size.
  define the method __init__ with 8 arguments: self, file, field_name, name, content_type, size, charset and content_type_extra set to None.
  vary_on is an empty tuple.
  try,
  import module io.
  define the method set with 5 arguments, self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  with the name of the module callback is in and the view_name, respectively, use it as the argument for the ValueError exception raise.   if response has an attribute named 'render' and response.render is a callable function,
  define the method open with arguments self and mode set to None.
  call the timezone.now function, substitute the result for now.
  substitute self.registered_checks for checks.
  define the method __repr__ with argument self.
  return context_extras.
  try,
  finally perform,
  self.verbose_name is a string 'cache entry'.
  call the self.read method with argument chunk_size, substitute the result for data.
  call the method self._cull.
  from django.core.files.move import file_move_safe into default name space.
  timeout is integer 300.
  from .messages import CheckMessage, Debug, Info, Warning, Error, Critical, DEBUG, INFO, WARNING, ERROR and CRITICAL into default name space.
  get property attribute _get_width, and substitute it for width.
  if self.base_url is None,
  context_extras is an empty dictionary.
  from django.core.files.utils import FileProxyMixin into default name space.
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  return an dictionary containing 1 entry: request for 'request'.
  substitute the self.DEFAULT_CHUNK_SIZE for chunk_size.
  call the exp.replace with microsecond set to integer 0, substitute the result for exp.
  substitute BOOL for UnlockFileEx.restype.
  derive the class MemoryFileUploadHandler from the FileUploadHandler base class.
  define the method open with arguments self and mode set to None.
  which has not been installed." with all the '%s' replaced by values of description, name and reference joined into a string delimited by '.', respectively,   obj set to receiver.__module__, hint set to None and id set to string 'signals.E001', append the result to errors.   return errors.
  call the method cursor.execute with string "UPDATE %s SET value = %%s, expires = %%s WHERE cache_key = %%s" as argument,
  call the function fcntl.flock with return value of the _fd(f) function and flags as arguments, substitute the result for ret.
  call the self.set method with key, new_value and version set to version as arguments.
  derive the class ContentFile from File base class.
  position the file pointer at the beginning of self file.
  do nothing.
  substitute message for self.message.
  call the function signals.request_finished.connect with argument close_caches.
  delete the value under the key key of self._expire_info dictionary.
  define the method multiple_chunks with arguments self and hunk_size set to None.
  do nothing.
  write current_chunk to file fd.
  return boolean False.
  l is lambda function with argument x, that calls the method self.make_key with x and version set to version as arguments.
  if tags is not None.
  reuturn cache.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  from __future__ import unicode_literals into default name space.
  substitute None for pickled.
  name is a property object with _get_name as a getter method and _set_name as a setter method.
  define the method close with argument self.
  get the position of the self.file file pointer, substitute it for pos.
  define the method all with argument self.
  close fd file.
  define the method file_complete with arguments: self and file_size.
  call the safe_join function with arguments self.location and name, substitute it for path.
  if message is an instance of dict type,
  call the self.path function with argument name, use the result as the argument for the call to the os.path.exists function, return the result.
  substitute the '%s' with table and list containing key, respectively.   call the cursor.fetchone method, substitute the result for row.
  call the function copystat with old_file_name and new_file_name as arguments.
  import module zlib.
  from django.conf import settings into default name space.
  do nothing.
  delete the value under the key key of self._cache dictionary.
  convert self.name into an boolean, return it.
  closed is a property object with _get_closed as a getter method.
  call the function func with request and response as arguments, assign the result to response.
  substitute the '%s' with table and 3 elements of a list: b64encoded, exp and key, respectively.   if DatabaseError exception is caught,
  if fname is contained in self._list_cache_files method return value,
  LOCK_NB is a hexadecimal 1.
  define the method upload_complete with argument self.
  aise and exception InvalidCacheBackendError with string "Could not find backend '%s': %s" as argument, replace '%s' with backend and e, respectively.
  call the function wrapped_callback with request, list or arguments callback_args and dictionary arguments callback_kwargs,
  return self._client.
  if ImportError exception occurred,
  define the get_many method with self class instance, keys and version set to None as arguments.
  buffer_ is None.
  if ValueError or TypeError exceptions occurred,
  if timeout equals to DEFAULT_TIMEOUT,
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  call the method make_key with arguments key and version from the base class of the class BaseMemcachedCache, use it as an argument for the call to the function force_str, return the result.
  define the method __repr__ with argument self.
  derive class ImageFile from the base class File.
  if key_func is not of None type,
  increment weight by integer 2.
  split server with ';' as delimiter, substitute the result for self._servers.
  substitute '%s' with self._dir converted to a string.   define the method key_to_file with self class instance, key and version defaulting to None as arguments.
  call the method self._cache.disconnect_all.
  define the method inner with argument check.
   from django.utils import timezone into default name space.
  with return value of the function io.open with fname and string 'rb' as arguments, named as f,
  return boolean True.
  as long as current_chunk is not an empty string,
  self.app_label is a string 'django_cache'.
  define the method get_backend_timeout with self and timeout set to DEFAULT_TIMEOUT as arguments.
  define the function _samefile with arguments src and dst.
  substitute self.version for version.
  call the function urlresolvers.set_urlconf with urlconf as the argument.
  set the file position pointer at the beginning.
  call the LockFileEx function with 6 arguments: hfile, flags, integer 0, integer 0, hexadecimal value FFFF0000, return value of the byref function called with argument overlapped, substitute the result for ret.
  import module glob.
  if val is None,
  call the new_file method form the base class from the MemoryFileUploadHandler class with arguments: unpacked list args and unpacked list kwargs.
  if message is an instance of ValidationError class,
  call the function locks.lock with arguments fd and locks.LOCK_EX.
  call the method self._delete with argument k.
  define the method clear with argument self.
  if not,
  if not,
  except if AttributeError is caught,
  if not,
  remove file tmp_path.
  define private method __repr__ with argument self.
  except if KeyError exception is caught,
  define the method __init__ with 4 arguments: self, message, code set to None and params set to None.
  call the method self._cache.incr with key and delta as arguments, substitute the result for val.
  import fcntl.
  write the chunk to the file _file.
  define the method get with 4 arguments, self class instance, key, default set to None and version set to None.
  define the method clear with argument self.
  models is a string 'models'
  if alias is not contained in setting.CACHES,
  if self.file has an attribute 'tell' and an attribute 'seek',
  from django.db.backends.utils import typecast_timestamp into default name space.
  substitute '%s' is "%s.process_response didn't return an HttpResponse object. It returned None instead.",
  content is a File object instance created with content argument.
  call the method self._expire_info.get with key and integer -1 as arguments, substitute the result for exp.
  if not,
  call the timezone.now function, substitute the result for now.
  call the params.get method wit string 'VERSION' and integer 1 as arguments, substitute the result for self.version.
  call the method tempfile.NamedTemporaryFile with arguments: suffix set to string '.upload' and dir set to settings.FILE_UPLOAD_TEMP_DIR.
  substitute settings.LANGUAGES for the value under the 'LANGUAGES' key of the context_extras dictionary.
  if os.name equals to 'nt',
  get attribute '_non_atomic_requests' from the view object, if the attribute doesnt exist return the empty set, substitute the result for non_atomic_requests.
  substitute message.message, message.code, message.params for message, code and params, respectively.
  define lambda function that returns self.file.tell field, use it as an argument for property function, put the result in tell.
  from django.core import signals into default name space.
  otherwise if self.object is an instance of the models.base.ModelBase class,
  renamed is boolean False.
  define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  define method has_key with self class instance, key and version set to None as arguments.
  break from the smallest enclosing loop.
  if not,
  property getter decorator,
  derive the class PyLibMCCache from BaseMemcachedCache base class.
  from threading import Lock into default name space.
  try,
  __all__ is a tuple containing strings: 'LOCK_EX', 'LOCK_SH', 'LOCK_NB', 'lock' and 'unlock'.
  if p.image is not empty,
  define the method __init__ with self class instance, file, and name defaulting to None as arguments.
  close the _file file.
  call the method urlresolvers.RegexURLResolver with raw literal string '^/' and urlconf as the arguments, substitute the result for resolver.
  try,
  define the method close with argument self.
  self.verbose_name_plural is a string 'cache entries'.
  if OSError or TypeError errors occurred.
  if self._cull_frequency equals to integer 0.
  if version is None,
  substitute the return value of the function abspathu with self.base_location as argument for self.location.
  _fields_ is a list containing 2 tuples: first tuple contains: string 'Offset' and DWORD, second contains: string 'OffsetHigh' and DWORD.
  'status code' with integer value of 400 and 'request' with value request, respectively use the previous to call the function security_logger.error.   if settings.DEBUG is True,
  if not,
  call the method self.get with key and version set to version as arguments, substitute the result for value.
  from io import BytesIO into default name space.
  context_extras is an empty dictionary.
  derive class Options from the base class object.
  from django.apps import apps into default name space.
  import module os.
  define the _setup method with argument self.
  derive class InvalidCacheBackendError from the ImproperlyConfigured base class.
  for every middleware_path in settings.MIDDLEWARE_CLASSES:
  convert key_prefix, version and key into strings, concatenate them respectively, with character ':' as delimiter, return the result.
  if version is None,
  if e.errno equals to errno.EEXIST,
  evaluate the function import_string with key_func as argument, return the result.
  define the method delete with self, key and version set to None as arguments.
  derive class BaseDatabaseCache from BaseCache base class.
  call the method urlresolvers.RegexURLResolver with raw literal string '^/' and urlconf as the arguments, substitute the result for resolver.
  delete the value under key key of self._cache dictionary.
  derive the class MiddlewareNotUsed from the Exception base class.
  for every i and k in enumerated values of self._cache, if i is divisible by self._cull_frequency, append k to doomed list.
  from django.core.files.uploadedfile import TemporaryUploadedFile and InMemoryUploadedFile into default name space.
  return the printable representation of the self object converted to a list.
  call the function force_str with argument self.obj, substitute the result for obj.
  from django.core import signals into default name space.
  self.charset and self.content_type_extra.   define the method receive_data_chunk with arguments: self, raw_data and start.
  if self.directory_permissions_mode is not None,
  substitute the '%s' with table and list containing key, respectively.   return default.
  define the method delete with self class instance, key and version set to None as arguments.
  call the method signals.got_request_exception.send with the sender set to the type of this class, and request set to request as the arguments.
  substitute '%s' in 'Internal Server Error: %s' with request.path, exc_info set to exc_info,
  call the method cursor.execute with string "DELETE FROM %s" as argument, substitute the '%s' with table.
  call the function os.fdopen with arguments fd and mode, substitute it for _file.
  call the function pickle.dumps with expiry and integer -1 as arguments, use the result as the argument for the call to f.write function.
  define the method __iter__ with argument self.
  from django.core.files import locks and File into default name space.
  call the method extend with an argument error_list on the return value of the method error_dict.setdefault called with 2 arguments: field and an empty list.
  call the method self.key_function with key, self.key_prefix and version as arguments, substitute the result for new_key.
  chunk_size is an integer 1024.
  call the function lazy with arguments _get_val and six.text_type, substitute the result for _get_val.
  if file path of src and dst files are the same, return boolean True, otherwise return boolean False.
  name set to self.file_name, content_type set to self.content_type, size set to file_size, charset set to self.charset,   and content_type_extra set to self.content_type_extra, return it.   define the function load_handler with arguments: path, unpacked list args and unpacked dictionary kwargs.
  derive the class CacheClass from the base class LocMemCache.
  call the self.incr method with key, negative delta and version set to version as arguments.
  if length of name is greater than integer 255,
  return errors.
  position file self.file pointer at the pos position.
  call the method b64encoded.decode with string 'latin1' as argument, substitute the result for b64encoded.
  from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
  substitute value for the value under the key key of self._cache dictionary.
  call the itertools.count function with argument integer 1, substitute the result for count.
  __all__ is a list containing a string 'file_move_safe'.
  raise an NotImplementedError exception with argument string 'subclasses of Storage must provide an accessed_time() method'.
  _fields_ is a list containing 4 tuples: first tuple contains: string 'Internal' and ULONG_PTR,
  import module cgi.
  or model._meta.app_config is contained in app_configs, for every field in model._meta.local_fields,  #ANNOTATION only if field is an instance of models.BooleanField and field.has_default() evaluates to False.    call the Warning function with 4 arguments: string "BooleanField does not have a default value.",
  define the method _set with 4 arguments, self class instance, key, value and timeout set to DEFAULT_TIMEOUT.
  evaluate the function import_string with middleware_path as argument, substitute the result for my_class.
  if self.size is greater than chunk_size, return boolean True, otherwise return boolean False.
  _meta is class Options class instance initialized with table argument.
  call the callback function with request and dictionary argument param_dict as the arguments, substitute it for response.
  define the method url with arguments self and name.
  derive the class Warning from base class CheckMessage.
  if name is not None,
  substitute c_ulong for ULONG_PTR.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  define the method apply_response_fixes with self class instance, request and response as the arguments.
  if ValueError or TypeError exceptions occurred,
  define private method __eq__ with self class instance and other as arguments.
  define the method __nonzero__ with argument self.
  call the method self.open()
  append field to problem_fields list for every model in apps.get_models with argument kwargs dictionary, only if app_configs is None,
  from django.utils.encoding import force_str into default name space.
  define the method file_complete with arguments self and file_size.
  define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  __all__ is a string containing strings: 'UploadFileException', 'StopUpload', 'SkipFile', 'FileUploadHandler',
  from django.utils.encoding import force_bytes and python_2_unicode_compatible into default name space.
  define the method has_key with self class instance, key and version defaulting to None as arguments.
  return the first element of the return value of the call to the self._det_image_dimensions method.
  substitute fcntl.LOCK_NB for LOCK_NB.
  define the method _has_expired with self and key as arguments.
  call the method self.get_available_name with argument name, substitute the result for name.
  return a string 'Raw content'.
  errors is an empty list.
  call the function file_move_safe with tmp_path, fname, allow_overwrite set to boolean True as arguments.
  if error.params is true,
  evaluate the method self._cache.decr with key and negative delta as arguments, return the result.
  self.error_list is an empty list.
  binary or os.O_EXCL if allow_overwrite is boolean False, use the previous as the mode to open new_file_name file, assign the file descriptor to fd.   try,
  from django.utils.module_loading import import_string into default name space.
  define the method _cache with argument self.
  property getter decorator,
  define method get_exception_response, with self class instance, request, resolver and status_code as the arguments.
  substitute timeout for self.default_timeout.
  mode is a string 'wb' is chunk is instance of the type bytes, otherwise mode is a string 'wt'.
  define initialization method __init__, with self class instance as the argument.
  self.file is a instance of a class TemporaryUploadedFile initialized with arguments: self.file_name, self.content_type, integer 0,
  from django.core.handlers import base into default name space.
  from django.utils.six.moves import cPickle as pickle, into default namespace.
  __caches is an empty dictionary.
  if ValueError exception is caught,
  substitute settings.MEDIA_URL for base_url.
  define the initialization method __init__ with self, table and params as arguments.
  derive the class Critical from base class CheckMessage.
  define the method _set_size with arguments self and size.
  return boolean True if tag is contained in self.tags_available method return value, return False otherwise.
  from django.core.files import File into default name space.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  substitute the settings.MEDIA_ROOT for location.
  if data is false,
  else if timeout converted into an integer equals to integer 0,
  or settings.FILE_UPLOAD_PERMISSIONS if it is.   self.directory_permissions_mode is a tuple containing: directory_permissions_mode if directory_permissions_mode is not None,
  if not,
  return nothing.
  call the os.rename function with arguments old_file_name and new_file_name.
  return error_dict.
  increment weight by integer 2.
  substitute the '%s' with table and list containing return value of the method call ops.value_to_db_datetime with argument now on the object under the db key of connections dictionary, respectively.   if exists return next entry from the database that cursor points at.
  return boolean False.
  call the method self.make_view_atomic with callback as the argument, substitute the result for the wrapped_callback.
  message is an instance of the ValidationError class created with an argument message.
  define the method size with arguments self and name.
  try,
  decorator register with Tags.models as an argument.
  if response is None,
  if e.errno equals to errno.EEXIST,
  __all__ is a list containing next strings, 'CheckMessage', 'Debug', 'Info', 'Warning', 'Error', 'Critical',
  if not,
  import module hashlib.
  if not,
  call the self._cache.get method with argument key, substitute the result for val.
  from django.utils import six into default name space.
  call the os.path.samefile with arguments src and dst, return the result.
  return an empty list.
  define the method set_many with self, data, timeout set to DEFAULT_TIMEOUT and version set to None as arguments.
  on the object under the db key of connections dictionary call the method ops.value_to_db_datetime with argument exp, substitute the result for the exp.
  call the method cursor.execute with string "SELECT cache_key, expires FROM %s WHERE cache_key = %%s" as argument,
  if call to the function os.path.exists with argument directory evaluates to boolean False,
  self.error_dict is an empty dictionary.
  call the LockFileEx function with 5 arguments: hfile, integer 0, integer 0, hexadecimal value FFFF0000, return value of the byref function called with argument overlapped, substitute the result for ret.
  convert app and model._meta.object_name to strings, join them with separating '.' character, substitute it for obj.
  return key_func.
  if KeyError exception is caught,
  substitute registry.register for register.
  raise an NotImplementedError exception with argument string 'subclasses of Storage must provide an exists() method'.
  try,
  call the __init__ method from the base class of the TemporaryFileUploadHandler class with arguments: unpacked list args,
  define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
  return val.
  define the initialization function __init__ with self class instance and params as arguments.
  raise an exception of class ValueError, with string "Key '%s' not found" as argument, where '%s' is substituted for key.
  call the method self.make_key with key and version set to version as arguments, substitute it for key.
  from django.core.urlresolvers import set_script_prefix into default name space.
  set the attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary to value, return it.
  decorator register with argument Tags.compatibility.
  define the method exists with arguments self and name.
  define the function _check_test_runner with app_config set to None and kwargs dictionary as arguments.
  if chunk_size is false,
  define the method get_backend_timeout with self class instance and timeout set to DEFAULT_TIMEOUT as arguments,
  delete the value under key key of self._expire_info.
  description is a string "An instance of the '%s' class" with '%s' replaced by value of receiver.__class__.__name__.
  from django.db import models into default name space.
  call the get_valid_filename with argument name, return the result.
  substitute the first 255 elements of ext for ext.
  define the method get with 4 arguments: self, key, default set to None and version set to None.
  define the function get_image_dimension with file_or_path and close set to boolean False as the arguments.
  define the method path with arguments self and name.
  define the method __eq__ with self and other as arguments.
  call the method unlink on self with self.name as the argument.
  if DEFAULT_CACHE_ALIAS is not contained in settings.CACHES,
  from django.utils.six.moves.urllib.parse import urljoin into default name space.
  do nothing.
  import module time.
  for every middleware_method in self._template_response_middleware,
  substitute _ for ret.
  do nothing.
  derive the class BaseCache from the object base class.
  if length of key is greater than MEMCACHE_MAX_KEY_LENGTH,
  define the method clear with self class instance as the argument,
  define the method __init__ with argument self, server and params.
  if request has an attribute named 'urlconf',
  _anonymous_ is a list containing one string: '_offset'.
  do nothing.
  if pickled is not None.
  LockFileEx.argtypes is a list containing 6 elements: HANDLE, DWORD, DWORD, DWORD, DWORD and LPOVERLAPPED.
  derive the class SuspiciousMultipartForm from the SuspiciousOperation base class.
  define the initialization method __init__ with self class instance and table as arguments.
  breaks from the smallest enclosing loop execution.
  execute regardless of the exception being raised,
  define the method get_available_name with arguments self and name.
  'TemporaryFileUploadHandler', 'MemoryFileUploadHandler', 'load_handler' and 'StopFutureHandlers'.   derive the class UploadFileException from the Exception base class.
  from itertools import chain into default name space.
  from shutil import copystat into default name space.
  define the function media with an argument request.
  _file is None.
  if string 'django.middleware.clickjacking.XFrameOptionsMiddleware' is not contained in settings.MIDDLEWARE_CLASSES set,
  define the method __init__ with arguments self and request defaulting to None.
  substitute content_length for self.content_length.
  define the method get with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  define the private method __contains__ with self class instance and key as arguments.
  from django.core.exceptions import SuspiciousFileOperation into default name space.
  call the function settings.is_overridden with argument string 'ADMINS', if it evaluates to boolean True,
  substitute request.urlconf for urlconf.
  define the method chunks with arguments self and chunk_size defaulting to None.
  if self.activated is boolean True,
  from .. import Warning, register and Tags into default name space.
  return boolean True, otherwise return boolean False.   define private method __ne__ with self class instance and other as arguments.
  __all__ is a tuple containing strings: 'UploadedFile', 'TemporaryUploadedFile', 'InMemoryUploadedFile' and 'SimpleUploadedFile'.
  call the __init__ method with arguments file and name, from the base class of the UploadedFile class.
  call the __init__ method with stream_class(content) and name set to name arguments, from the base class of the ContentFile class.
  define the method listdir with arguments self and path.
  from __future__ import unicode_literals into default name space.
  import module base64.
  if call to the function _samefile with old_file_name and new_file_name evaluates to boolean True,
  from __future__ import unicode_literals into default name space.
  do nothing.
  define the method validate_key with self class instance and key as arguments.
  derive the class MemcachedCache from the BaseMemcachedCache base class.
  call the function force_bytes with argument value, use the result as an argument for the call to the method base64.b64decode,
  do nothing.
  call the function self._key_to_file with key and version as arguments, substitute it for fname.
  if not,
  from django.utils.encoding import smart_text into default name space.
  substitute the '%s' with table and list containing key, respectively.   fetch one entry from the database that cursor points at, substitute it for the result.
  if close is True,
  call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
  try,
  define the method add with 5 arguments: self, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  define the method __init__ with arguments self and connection_reset defaulting to boolean False.
  do nothing.
  return an empty list.
  if module os field name equals to string 'nt',
  substitute name for self.name.
  __all__ is a tuple containing strings: 'Storage', 'FileSystemStorage', 'DefaultStorage' and 'default_storage'.
  call the function os.remove with argument fname.
  call close method on a file stream.
  define lambda function that returns self.file.flush field, use it as an argument for property function, put the result in flush.
  define the function file_complete with arguments self and file_size.
  get absolute directory path of dir, substitute it for self._dir.
  join into a string: md5 hash sum of force_bytes(key) and self.cache_suffix, compose root file path out of self._dir and previous result, return it.
  import module errno.
  define the method delete with self class instance, key and version defaulting to None as arguments.
  raise and exception InvalidCacheBackendError with string "Could not find config for '%s' in settings.CACHES" as argument, replace '%s' with alias.
  from django.conf import settings into default name space.
  import module tempfile.
  if self object has an attribute '_client',
  call the self._cull method.
  call the method self.set with key, value, version incremented by delta, as arguments.
  if response is True,
  define the method decr_version with 4 arguments, self, key, delta defaulting to integer 1 and version defaulting to None.
  define the method decr with self, key, delta defaulting to integer 1 and version defaulting to None as arguments.
  import module warnings.
  try,
  call the function conf.copy, substitute it for params.
  define the method close with self and dictionary pairs of elements kwargs.
  from django.core.files.utils import FileProxyMixin into default name space.
  return an dictionary containing 1 entry: settings.STATIC_URL for 'STATIC_URL'.
  from django.utils.encoding import force_text into default name space.
  decorator deconstructible,
  substitute size for self.size.
  call the method self._set with key, pickled and timeout as arguments.
  from django.utils.module_loading import import_string into default name space.
  MEMCACHE_MAX_KEY_LENGTH is integer 250.
  for every key and value in data.items method return value,
  try,
  if self._dir file path does not exists,
  from django.utils.module_loading import import_string into default name space.
  define the method __init__ with self, server and params as arguments.
   if settings.FILE_UPLOAD_TEMP_DIR is true,
  do nothing.
  raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a delete() method' as argument.
  call the function self._key_to_file with key and version as arguments, use the result as an argument for the call to the self._delete method.
  return size of the image that was fed to the parser p.
  call the method cursor.execute with string "DELETE FROM %s WHERE expires < %%s" as argument,
  errors is an empty list
  import module time.
  for every chunk in return value of the method self.chunks,
  position the file pointer at the start of the self.file file.
  call the method new_file from the base class of the TemporaryFileUploadHandler class with arguments: file_name, unpacked list args and unpacked dictionary kwargs.
  and stacklevel set to 2 as arguments.   call the _create_cache with backend and dictionary kwargs as arguments, substitute the result for cache.
  if ImportError exception occurred,
  call the method self._cache.decr with key and delta as arguments, substitute the result for val.
  call the os.stat function with argument src, substitute the result for st.
  remove the old_file_name file.
  call the function resolver.resolve_error_handler with status_code as an argument, assign the result to the callback and param_dict, respectively.
  return boolean True.
  return an dictionary containing 1 entry: settings.MEDIA_URL for 'MEDIA_URL'.
  if settings.DEBUG is true and value of the request.META dictionary under the 'REMOTE_ADDR' key is contained in settings.INTERNAL_IPS,
  if expires is lesser than now,
  call the method self._lib.Client with argument self._servers.
  define the method _cache with self class instance as an argument.
  for every reference and receivers in return value of the call of obj.unresolved_references.items method,
  if mw_instance has an attribute named 'process_view'.
  substitute CacheEntry for self.cache_model_class.
  self.managed is boolean True.
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  define the function i18n with an argument request.
  do nothing.
  define the method _get_image_dimensions with self class instance as the argument.
  raise an ValueError exception with string "Key '%s' not found" as argument, substitute '%s' for key.
  open file old_file_name in read bytes mode, with file descriptor as f,
  define the method listdir with arguments self and path.
  define the method decr with arguments self, key, delta defaulting to integer 1 and version defaulting to None.
  define the close method with 2 arguments, self and dictionary of argument pairs kwargs.
  if not,
  call the model.check method with unpacked dictionary kwargs for every model in return value of function apps.get_models,
  if timeout is greater than integer 2592000,
  import module os.
  try,
  define the method get_many with 3 arguments, self class instance, keys and version set to None.
  raise an ValueError exception with string "The file cannot be reopened." as an argument.
  WARNING is integer 30.
  derive class CheckMessage from object base class.
  substitute v for value under the k-th element of m key of _ dictionary.
  for every middleware_method in self._exception_middleware,
  substitute file_size for self.file.size.
  return context_extras.
  do nothing.
  derive the class OVERLAPPED from the Structure base class.
  derive the class FieldError from the Exception base class.
  substitute model._meta.app_label for app.
  return new_value.
  try,
  self._caches.caches is an empty dictionary.
  substitute error.message for message.
  import module pickle.
  from __future__ import unicode_literals into default name space.
  feed data to the parser p.
  join path and entry into a file path, if it exists,
  if os.path has an attribute 'samefile',
  with return value of the function transaction.atomic with using set to db as arguments, perform the following,
  do nothing.
  return an dictionary containing 1 entry: return value of the function timezone.get_current_timezone_name for 'TIME_ZONE'.
  call the function transaction.atomic, with using set to db.alias as the argument, return value is a function which is called,
  define the method update_error_dict with arguments self and error_dict.
  if not,
  derive CacheEntry class from the object base class.
  from threading import local into default name space.
  import msvcrt.
  self.charset is None.
  replace all '%s' from string "%s: %s%s%s" with values of obj, id, self.msg and hint, respectively, return the result.
  call the method cursor.execute with string "SELECT COUNT(*) FROM %s" as argument, substitute the '%s' with table.
  define the method __multiple_chunks__ with arguments self and chunk_size defaulting to None.
  try,
  for every check in checks,
  if content is empty, substitute it for an empty string.
  return val.
  use the result as an argument for the call to the function datetime.fromtimestamp, return the result.   define the method created_time with arguments self and name.
  property decorator,
  define the function file_move_safe with 4 arguments: old_file_name, new_file_name, chunk_size set to multiple of integers 1024 and 64,
  use the result as the argument for the function call to the pickle.loads, return the result.   define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  return boolean True.
  from django.utils import six into default name space.
  if num_entries is lesser than self._max_entries,
  substitute StringIO for stream_class if content is an instance of six.text_type, otherwise substitute BytesIO for stream_class.
  call the params.get method with string 'KEY_PREFIX' and an empty string as arguments, substitute the result for self._key_prefix.
  if ret equals to integer 0, return boolean True, otherwise return boolean False.
  return self.
  return boolean False.
  self.activated is boolean False.
  call the _expire_info.setdefault method with name and empty dictionary as arguments, substitute the result for self_expire_info.
  substitute windll.kernel32.LockFileEx for LockFileEx.
  define the function lock with arguments f and flags.
  extra is an dictionary with two pairs of elements 'status_code' with value 500, and 'request with value request,   respectively use the previous as the arguments for the call to the logger.error function.   if settings.DEBUG is True,
  from django.core.exceptions import MiddlewareNotUsed, PermissionDenied and SuspiciousOperation into default name space.
  derive the class CacheClass from the DatabaseCache base class.
  call the __bool__ method with argument self, on the return value of the type function with argument self, return the result.
  call the self.get method with k and version set to version as arguments, substitute the result for val.
  import module time.
  call the function _check_boolean_field_default_value with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.
  derive the class StopUpload from the UploadFileException base class.
  if timeout is None,
  substitute False for self.close_called.
  append check to checks list, for every check in self.register_checks, if check has an attribute 'tags' and check.tags and tags set intersection is a non empty set.
  define the function unlock with argument f.
  return new_value.
  if self.file has an attribute 'size',
  substitute windll.kernel32.UnlockFileEx for UnlockFileEx.
  'CacheKeyWarning' and 'BaseCache'   DEFAULT_CACHE_ALIAS is a string 'default'.
  from django.db import connections and transaction into default name space.
  for every fname in return value of the glob.glob1 function called with 2 arguments: self._dir and ,
  raise an IOError exception with string "Destination file %s exists and allow_overwrite is False" as argument, where '%s' is replaced by new_file_name.
  return self.
  return an dictionary containing 1 entry: return value of the function _get_val for 'csrf_token'.
  define the method size with arguments self and name.
  if val is None,
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  from django.core.exceptions import ImproperlyConfigured into default name space.
  if os has an attribute 'chmod',
  define initialization method __init__ with self class instance, level, msg, hint defaulting to None, obj defaulting to None and if defaulting to None as arguments.
  finally perform,
  if exception PermissionDenied is caught,
  call the self.path with argument name, use the result as an argument for the call to the os.path.getsize function, return the result.
  try,
  call the method params.get with 2 arguments, string 'KEY_FUNCTION' and None, use the result as the argument for the call to the function get_key_func, substitute the result for the self.key_func.
  substitute name for self.name.
  for every receiver, _ and _ in receivers,
  val is None.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  define the function default_key_func with 3 arguments, key, key_prefix and version.
  define the method modified_time with arguments self and name.
  call to the resolver.resolve method with request.path_info as an argument.
  decorator python_2_unicode_compatible,
  delete the value under the key key of the self._expire_info dictionary.
  derive class BaseHandler, derive from the base class object, making this a new style class.
  if not,
  call the self._lock.reader method, with the result perform the following,
  try,
  if self has an 'error_dict' attribute,
  if AttributeError or UnsupportedOperation exception occurred.
  derive the class BaseMemcachedCache from base class BaseMemcachedCacheMethods and BaseCache.
  define lambda function that returns self.file.read field, use it as an argument for property function, put the result in read.
  try,
  from django.utils import six into default name space.
  else if timeout equals to integer 0,
  define the method tags_available with argument self.
  self.file_name is None.
  define lambda function that returns self.file.readline field, use it as an argument for property function, put the result in readline.
  substitute the location for self.base_location.
  substitute code for self.code.
  call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
  if not,
  do nothing.
  call the method connections.all(), perform the following for every db in the result,
  as the arguments, substitute the result for response.   try,
  call the self._lock.reader method, with the result perform the following,
  _ is an empty dictionary.
  try,
  if key if contained in value under the DEFAULT_CACHE_ALIAS key of caches dictionary, return boolean True, otherwise return False.
  bring integer 2 to the power of 10, multiply it by 64, substitute the result for DEFAULT_CHUNK_SIZE.
  if OSError, renamed to e, is caught,
  return None.
  from django.utils.encoding import python_2_unicode_compatible and force_st into default name space.
  from django.utils.functional import LazyObject into default name space.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  define the method receive_data_chunk with arguments: self, raw_data and start.
  define the method handle_raw_input with arguments: self, input_data, META, content_length, boundary and encoding set to None.
  raise an exception.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  if timeouts is None return None, otherwise return the sum of function time.time return value and timeout.
  close the file self.
  from __future__ import unicode_literals into default name space.
  if exception OSError, renamed to e, is caught,
  call the __init__ method from the base class of the SimpleUploadedFile class with 7 arguments: BytesIO(content), None, name,
  call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
  if not,
  if MiddlewareNotUsed exception is raised,
  call the method self.validate_key with key as argument.
  define the function _get_val.
  define the method closed with self as the argument.
  replace all the '%r' with self.level, self.msg, self.hint. self.obj and self.id, respectively, return the result.   define the method is_serious with argument self.
  substitute True for self.close_called.
  increment weight by integer 2.
  import module warnings.
  if mode equals to string 'add' and current_expires is lesser than now, or mode equals to string 'set', and result is true,
  otherwise if self.name exists and self.name file path exists,
  derive the class LocMemCache from the base class BaseCache.
  call the function os.makedirs with argument directory.
  call the __init__ method with self and params arguments from the base class BaseCache.
  define the function _check_middleware_classes with app_config set to None and kwargs dictionary as arguments.
  if ImportError, renamed to e, is caught,
  substitute connection_reset for self.connection_reset.
  if self.activated is boolean True,
  define __del__ method with self as the argument.
  import memcache.
  import module errno.
  define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  raise an exception.
  from itertools import chain into default name space.
  replace all the strings '\\' with '/' in the string name, use it as an argument for the call to the force_text function, return the result.
  from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
  if self.LibraryValueNotFoundException exception is caught,
  return integer 0.
  all the function fcntl.flock with return value of the _fd(f) function and fcntl.LOCK_UN as arguments, substitute the result for ret.
  define the method exists with arguments self and name.
  evaluate method self.has_key with key and version as arguments, if the result is true,
  define the method _createdir with argument self.
  return response.
  define the function debug with an argument request.
  evaluate the binary expression with 4 operands: os.O_WRONLY, binary or os.O_CREATE, binary or 'O_BINARY' attribute of object os,
  call the function datetime.utcfromtimestamp with argument timeout, substitute it for exp.
  import module django.core.checks.compatibility.django_1_6_0.
  call the function os.chmod with arguments dst and mode.
  with previous result and list containing cull_num, respectively as arguments.   call the method cursor.execute with string "DELETE FROM %s WHERE cache_key < %%s" as argument,
  description is a string "The '%s' function" replaced by value of receiver.__name__.
  raise an exception.
  from django.conf import settings into default name space.
  close the file fd.
  if not,
  cache_suffix is a string '.djcache'.
  try,
  raise an NotImplementedError exception with argument string "This backend doesn't support absolute paths.".
  substitute content.name for name.
  if self does not have an attribute named '_dimensions_cache'.
  define the method _is_expired with self and f as arguments.
  raise an exception.
  derive DatabaseCache from the BaseDatabaseCache base class.
  substitute c_void_p for PVOID.
  if self has an attribute 'error_dict',
  if not,
  call the method self._cache_flush_all.
  if self.file has an attribute 'name',
  set class fields _request_middleware, _view_middleware, _template_response_middleware, _response_middleware and _exception_middleware to None.
  define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  import module tempfile.
  as the arguments, substitute the result for response.   if Exception, renamed to e, exception is caught,
  if exception OSError, renamed to e, occurred,
  for every error in self.error_list,
  define lambda function that returns self.file.softspace field, use it as an argument for property function, put the result in softspace.
  call the self._lock.writer method, with the result perform the following,
  for every key in keys,
  call the method self.validate_key with argument key.
  call the method urlresolvers.set_urlconf with urlconf as the argument.
  call the method cursor.execute with string "SELECT cache_key FROM %s WHERE cache_key = %%s and expires > %%s" as argument,
  try,
  from io import BytesIO into default name space.
  position the file pointer at the beginning of self file.
  substitute the '%s' with table and list containing return value of the method call ops.value_to_db_datetime with argument now on the object under the db key of connections dictionary, respectively.   call the method cursor.execute with string "SELECT COUNT(*) FROM %s" as argument, substitute the '%s' with table.
  if AttributeError exception is caught,
  call the DefaultCacheProxy function, substitute it for cache.
  as long as self.exists function with argument name evaluates to boolean True,
  for every message is message,
  fetch one record from the database cursor points at, substitute the first element of return value for num.
  do nothing.
  define the function receive_data_chunk with arguments self, raw_data and start.
  call the function locks.unlock with argument fd.
  'status_code' with value 403, and 'request with value request,   respectively use the previous as the arguments for the call to the logger.warning function.   call the method self.get_exception_response with request, resolver and integer 403 as the arguments, assign the result to response.
  return nothing.
  if not,
  if for all attr in list of attributes 'level', 'msg', 'hint', 'obj' and 'id', self and other have the same attribute attr,
  call the os.fdopen function with fd, mode and bufsize as the arguments, assign the file handle object to self.file.
  if KeyError exception is caught,
  define the method _delete with arguments self and key.
  if resolver.urlconf_module is None:
  define the method has_key with 3 arguments: self, key, and version set to None.
  derive the class Info from base class CheckMessage.
  raise an ValueError exception with string "Key '%s' not found" as argument, substitute '%s' for key.
  call the function pickle.dumps with argument value, use the result and integer -1 as arguments for the call to the function zlib.compress, use the result as an argument for the call to the f.write method.
  if not,
  if renamed is boolean False,
  from PIL module import ImageFile as PillowImageFile.
  __all__ is a tuple, containing strings 'NamedTemporaryFile' and 'gettempdir'.
  if not,
  dir set to None as the arguments.   call the method tmpfile.mkstemp with suffix set to suffix, prefix set to prefix and dir set to dir, store the result in the fd and name, respective.
  call the function pickle.load with argument f, substitute the result for exp.
  substitute c_int64 for ULONG_PTR.
  call the self.get method with arguments key and version set to version, substitute the result for value.
  delete the attribute name from the cache dictionary under the DEFAULT_CACHE_ALIAS key.
  if not,
  from __future__ import unicode_literals into default name space.
  define the method save with arguments self, name and content.
  call the self.clear method.
  derive the class DisallowedRedirect from the SuspiciousOperation base class.
  define the method __init__ with arguments self, argument list args and dictionary of arguments kwargs.
  substitute line for buffer_.
  from __future__ import unicode_literals into default name space.
  define the method _list_cache_files with argument self.
  call the method self._lib.Client with self._servers and pickleProtocol set to pickle.HIGHEST_PROTOCOL as arguments, substitute the result for self._client.
  and directory_permissions_mode set to None.   if location is None,
  do nothing.
  call the method self.validate_key with argument key.
  call the middleware_method with request and e as the arguments, substitute the result for response.
  if value under the DEFAULT_CACHE_ALIAS key of caches dictionary is not equal to other, return boolean True, otherwise return False.
  call the BaseCache.__init__ method with self class instance and params as the arguments.
  define the function copystat with arguments src and dst.
  try,
  call the function self.path with argument name, use the result as an argument for the call to the function os.path.getmtime,
  from django.utils.functional import lazy into default name space.
  if response is None,
  content_type, length of content, None and None.   decorator classmethod.
  call the method self._cache.get_multi with argument new_keys, substitute the result for ret.
  call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
  if self.activated is boolean False,
  define the method set_many with arguments, self, data, timeout defaulting to DEFAULT_TIMEOUT and version set to None.
  if features.needs_datetime_string_cast field of object under the db key of connections dictionary is true and current_expires is not an instance of datetime object.
  call the check function with argument app_config set to app_config, substitute the result for new_errors.
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  call the method close on self.
  derive the class DefaultCacheProxy from the base class object.
  __locks is an empty dictionary.
  from __future__ import unicode_literals into default name space.
  call the method self.get_backend_timeout with argument timeout, substitute it for expiry.
  close is boolean True.
  for every fname in filelist,
  define method load_middleware with class instance self as the argument.
  call the _caches.setdefault method with name and empty dictionary as arguments, substitute the result for self_cache.
  from django.utils.deconstruct import deconstructible into default name space.
  compatibility is a string 'compatibility'.
  break from the smallest enclosing loop execution.
  if any exception is caught,
  call the method self.validate_key with key as argument.
  define __enter__ method with self as the argument.
  raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a url() method'.
  return self.file.size.
  return result of the f.fileno method if f has an 'fileno' attribute, otherwise return f.
  call the method self.validate_key with argument key.
  set the file pointer at the beginning of the self.file file.
  if not,
  if value under the DEFAULT_CACHE_ALIAS key of caches dictionary equals to other, return boolean True, otherwise return False.
  substitute pickled for value under the key key of self._cache dictionary.
  try,
  property decorator, to be called by property built-in function.
  status code set to integer 400, return the result.   call the method self.get_exception_response with the request, resolver and integer 400 as the arguments, substitute the result for response.
  call the method self.validate_key with argument key.
  derive the class CacheClass from the DummyCache base class.
  substitute TemporaryFile for NamedTemporaryFile.
  messages is an instance of the ValidationError class created with an argument messages.
  define the method _get_size with argument self.
  if ascii value of char is smaller than integer 33 or is equal to integer 127,
  from django.utils import datastructures into default name space.
  evaluate the method get_image_dimensions with self class instance and close set to close as the arguments, substitute the result for self._dimensions_cache.
  call the method self.make_key with key and version set to version as arguments, substitute it for key.
  substitute value under the backend key of settings.CACHES dictionary for conf.
  define the method _set_name with arguments self and name.
  return d.
  if not,
  from functools import reduce into default name space.
  define the function get_key_func with argument key_func.
  import module operator.
  if self.close_called is False,
  define lambda function that returns self.file.writelines field, use it as an argument for property function, put the result in writelines.
  call the self.file.close method, return the result.
  evaluate self.clear method and return the result.
  substitute msg for self.msg.
  _anonymous_ is a list containing one string: '_offset_union'.
  raise an NotImplementedError with argument string 'subclasses of FileUploadHandler must provide a receive_data_chunk() method'.
  define the method run_checks with self class instance, app_configs defaulting to None, tags defaulting to None as argument.
  if value under the key 'ATOMIC_REQUESTS of db.settings_dic dictionary is True and db.alias is not present in the non_atomic_requests,
  substitute level for self.level.
  otherwise if message is an instance of the list type.
  if self._cull_frequency equals to integer 0.
  if not,
  return self._name.
  from django.core.cache.backends.base import InvalidCacheBackendError, CacheKeyWarning and BaseCache into default name space.
  try,
  if response is None,
  derive the class _OFFSET_UNION from the Union base class.
  size is a property object with _get_size as getter method and _set_size as setter method.
  get the name of the type of the callback, append the string '.__call__' to it, substitute it for view_name.
  define the method make_key with self class instance, key and version defaulting to None as arguments.
  do nothing.
  derive the class ValidationError from the Exception base class.
  return default.
  call the function os.path.dirname with argument full_path, substitute the result for directory.
  endless while loop,
  substitute file for self.file.
  define the function unlock with argument f.
  return boolean True.
  define the method _cull with argument self.
  if self has an 'error_dict' attribute,
  raise an exception ImproperlyConfigured with string "You must define a '%s' cache" as argument, with '%s' replaced with DEFAULT_CACHE_ALIAS converted into a string.
  if ImportError, renamed to e, exception is caught,
  if val is not None,
  write raw_data to self.file file.
  renamed methods is a tuple containing 3 elements: '_get_memcache_timeout', 'get_backend_timeout' and RemovedInDjango19Warning.
  call the Warning function with 3 arguments: hint tuple containing one string, Django 1.6 introduced a new default test runner.
  call the self._lock.writer method, with the result perform the following,
  from django.db import models into default name space.
  define the __getitem__ method with self and alias arguments.
  call the function stat.S_IMODE with argument st.st_mode, substitute the result for mode.
  define the method get_response, with self class instance and request as the arguments.
  with the argument view, store the result in the view.   return view
  define the method get_many with 3 arguments: self, keys, and version set to None.
  define the method __str__ with argument self.
  derive class CacheKeyWarning from the DjangoRuntimeWarning base class.
  substitute the '%s' with table and 3 elements of a list: b64encoded, exp and key, respectively.   if not,
  and MEMCACHE_MAX_KEY_LENGTH, call the function warnings.warn with previous string and CacheKeyWarning as arguments.   for every char in key,
  if receiver is an instance of types.FunctionType type,
  for name in attributes of models_signals object,
  if KeyError exception is caught,
  self.request is None.
  if IOError, renamed to e, exception is caught,
  call the method self.validate_key with argument key.
  call the self.validate_key method with argument key.
  call the self.path function with argument path, substitute it for path.
  call the method self._cache.set_multi with safe_data, self.get_backend_timeout(timeout) as arguments.
  call the method now.replace with argument tzinfo set to None, substitute it for now.
  convert ret to a boolean, return it.
  try,
  derive the class DjangoRuntimeWarning from the RuntimeWarning base class.
  __expire_info is an empty dictionary.
  convert timeout into an integer.
  define the method __init__ with, self, server, params, library, value_not_found_exception as arguments.
  if _file is None,
  call the function now.replace with microseconds set to integer 0, substitute the result for now.
  call the function file_move_safe with content.temporary_file_path function result and full_path.
  yield field and ValidationError object converted to an list, created with an argument errors.
  return self._dimensions_cache.
  finally perform,
  call the function force_bytes with argument content, substitute it for content.
  if not,
  derive the TemporaryUploadedFile class from the UploadedFile base class.
  if value is None,
  if not,
  define the method open with arguments self and mode defaulting to None.
  insert mw_instance.process_template_response at the beginning of self._template_response_middleware.
  return boolean False.
  from django.db import connection into default name space.
  substitute messages.error_list for the value under the field key of the self.error_dict dictionary.
  if timeout is None,
  call the method self.make_key with key and version set to version as arguments, substitute it for key.
  call the function logging.getLogger with string 'django.request' as the argument, assign the return object handle to logger.
  raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a listdir() method'.
  call the function cache.close.
  define the method make_view_atomic, with self class instance and view as the arguments.
  derive the class AppRegistryNotReady from the Exception base class.
  in the string "<%s: level=%r, msg=%r, hint=%r, obj=%r, id=%r>", replace '%s' with the name of the type of this class instance,
  define the method is_silence with argument self.
  get attribute 'caches' from the self._caches if exists, otherwise get an empty dictionary, call the values method on the return value, return it.
  set file pointer at the beginning of the self.file file.
  if new_errors is not an iterable object raise an error with error message "The function %r did not return a list. All functions registered with the checks registry must return a list.", with '%s' replaced by value of check.
  if not,
  from datetime import datetime into default name space.
  call the method __init__ from the base class of the TemporaryUploadedFile class with arguments: file, name, content_type, size, charset and content_type_extra.
  call the function _check_test_runner with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.
  call the method self._cache.delete with argument key.
  substitute tempfile.NamedTemporaryFile for NamedTemporaryFile.
  from __future__ import unicode_literals into default name space.
  append entry to files list.
  if message has an 'error_dict' attribute,
  substitute self.default_timeout for timeout.
  import module hashlib.
  from django.core.files.base import File into default name space.
  derive the class TemporaryFileUploadHandler from the FileUploadHandler base class.
  derive the class CheckRegistry with object as base class.
  UnlockFileEx.argtypes is a list containing 5 elements: HANDLE, DWORD, DWORD, DWORD and LPOVERLAPPED.
  close the file object.
  return boolean True.
  raise an exception.
  substitute content_type for self.content_type.
  if key_function is callable object,
  silent_variable_failure is an boolean True.
  skip this iteration of he smallest enclosing loop.
  decorator python_2_unicode_compatible.
  if chunk_size is false,
  substitute id for self.id.
  call the method self.get_backend_timeout with argument timeout, substitute the result for timeout.
  call the method self.set with arguments key, value, timeout set to timeout, version set to version.
  define the method handle_uncaught_exception with self class instance, request, resolver and exec_info as arguments.
  if self._options exists,
  define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
  return default.
  raise an ValueError exception with string "Key '%s' not found" as argument, substitute '%s' with key converted into a string.
  call method __init__ from the base class of the class MemcachedCache with arguments: server, params,
  import module os.
  only if app_configs is None ot model._meta.app_config is contained in app_configs, error is a list containing all the previous elements.   chain all errors elements into a list, return it.
  self.file_permissions_mode is a tuple containing: file_permissions_mode if file_permissions_mode is not None,
  from .registry import register, run_checks, tag_exists and Tags into default name space.
  if OSError, renamed to e, exception is caught,
  if exp is not None and exp is lesser than return value of the function time.time,
  get 'name' attribute from the file object, if it doesnt exists use None, substitute it for name.
  define the method close with argument self.
  append ext to the end of it, substitute the resulting list for name.   substitute name for self._name.
  if num is greater than self._max_entries,
  define the method set_many with 4 arguments: self, data, timeout set to DEFAULT_TIMEOUT and version set to None.
  if KeyError exception is caught,
  call the method self._set with key, pickled and timeout as arguments.
  if val is None,
  directories, files are empty lists.
  substitute value under the key key of self._cache dictionary for pickled.
  if file self is not closed,
  call the method self.validate_key with argument key.
  substitute tempfile.gettempdir for gettempdir.
  call the import_string with arguments path, call the return function with arguments: unpacked list args and unpacked dictionary kwargs, return the result.
  define the function tz with an argument request.
  define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
  from django.utils.encoding import smart_text into default name space.
  do nothing.
  from django.conf import settings into default name space.
  do nothing.
  if messages is not an instance of the ValidationError class,
  if settings.DEBUG_PROPAGATE_EXCEPTIONS is True,
  substitute file_or_path for file.
  self.proxy is boolean False.
  zip together new_keys and keys, convert it to dictionary, assign it to m.
  call the method self.validate_key with argument key.
  substitute the '%s' with table and list containing first element of cursor.fetchone method, respectively.   define the method clear with argument self.
  safe_data is an empty dictionary.
  call the function pickle.dumps with value and pickle.HIGHEST_PROTOCOL as the arguments, substitute the result for pickled.
  if check is not contained in self.registered_checks.
  call the self.get method with key and version set to version as arguments, substitute the result for value.
  if self has an 'error_dict' attribute,
  define the method tag_exists with self class instance and tag as arguments.
  from django.utils.encoding import force_bytes into default name space.
  define private method __str__ with argument self.
  call the self._open method with name and mode arguments, return the result.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  evaluate the method type(self).__bool__ with argument self, return the result.
  call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
  from django.utils.deprecation import RemovedInDjango19Warning into default name space.
  from django.utils import six into default name space.
  define the method incr with 4 arguments, self class instance, key, delta defaulting to integer 1 and version defaulting to None.
  call the function signals.request_finished.connect with argument cache.close.
  if obj is instance of models.signals.ModelSignal class,
  if not,
  define the function delete_many with self, keys and version set to None as arguments.
  if _file is not None,
  define the function _check_boolean_field_default_value with app_config set to None and kwargs dictionary as arguments.
  if response is True,
  if self.hint exists, replace '%s' in a string "\n\tHINT: %s" with value of self.hint, substitute it for hint, otherwise hint is an empty string.
  call the self._lock.writer method, with the result perform the following,
  call the function that is the return value of get_storage_class method, substitute the result for self._wrapped.
  if exp is None or exp is greater than the return value of the call to the function time.time,
  substitute kwargs for params.
  CRITICAL is integer 50.
  import module zlib.
  if length of self._cache is greater or equal to self._max_entries,
  call the method self.incr_version with key, negative delta and version as arguments.
  call the function settings.is_overridden with argument string 'TEMPLATE_LOADERS', if it evaluates to boolean True,
  do nothing.
  substitute value for value under the key key of safe_data dictionary.
  substitute val for value under the k key of dictionary d.
  define the function _create_cache with backend and dictionary pair of elements kwargs as arguments.
  from django.core.files.base import File into default name space.
  call the function pickle.dumps with value and pickle.HIGHEST_PROTOCOL as the arguments, substitute the result for pickled.
  derive the class DummyCache from the base class BaseCache.
  for every k and v in return value of the ret.items function,
  define the function check_model_signals with app_config defaulting to None and unpacked dictionary kwargs as arguments,
  define method _get_width with self class instance as the argument.
  __all__ is an list containing a string 'File'.
  if OSError or IOError exceptions were raised,
  yield one element of line iterable.
  substitute message.error_dict for message.
  call the options.get method with string 'CULL_FREQUENCY' and integer 3 as arguments, use the string 'cull_frequency' and previous result as the arguments for the call to the params.get method, substitute the result for cull_frequency.
  call f.read function, use the result as the argument for zlib.decompress function call, call the pickle.loads function with the previous result as argument, return the result.
  define the method __str__ with argument self.
  define lambda function that returns self.file.readlines field, use it as an argument for property function, put the result in readlines.
  evaluate the function debug.technical_500_response with request, evaluated value of function sys.exc_info as a list,
  with the name of the type of the self class instance of the middleware_method, raise the ValueError with the previous as the argument.   call the method self.apply_response_fixes with the request and response as the arguments, substitute the result for response.
  raise an IOError exception with argument string "%s exists and is not a directory.", where '%s' is replaced by directory.
  return the string 'ValidationError(%s)', replace '%s' with self.
  or settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS if it is.   define the method _open with arguments self, name and mode defaulting to string 'rb'.
  call the method cursor.execute with string "INSERT INTO %s (cache_key, value, expires) VALUES (%%s, %%s, %%s)",
  define the function static with an argument request.
  call the translation.get_language function, substitute the result for the value under the 'LANGUAGE_CODE' key of the context_extras dictionary.
  increment line by buffer_.
  __all__ is an list containing 6 elements: 'get_cache', 'cache', 'DEFAULT_CACHE_ALIAS', 'InvalidCacheBackendError',
  call the signals.got_request_exception.send method with sender set to type of the self class instance and request set to request.
  if name is None,
  return val.
  if OSError exception is caught,
  set response to None.
  substitute self.default_timeout for timeout.
  define the method get_many with self class instance, keys and version defaulting to None as arguments.
  set the file position pointer at file_pos.
  substitute hint for self.hint.
  call the force_text with an argument message, yield the result.
  if result is true,
  substitute cache for value under the alias key of self._caches.caches dictionary.
  return nothing.
  call the function msvcrt.get_osfhandle with return value of the _fd(f) function as argument, substitute the result for hfile.
  call the method errors.extend with argument new_errors.
  timeout is a integer -1.
  append entry to the directories list.
  define the function make_template_fragment_key with fragment_name and vary_on defaulting to None as arguments.
  call the BaseCache initialization method __init__ with 3 arguments self, list of arguments args and dictionary of arguments kwargs.
  return cache.
  define lambda function that returns self.file.newlines field, use it as an argument for property function, put the result in newlines.
  substitute settings.ROOT_URLCONF for urlconf.
  from . import Error, Tags and register into default name space.
  call the function msvcrt.get_osfhandle with return value of the _fd(f) function as argument, substitute the result for hfile.
  call the Warning function with 4 arguments: string "MIDDLEWARE_CLASSES is not set.", hint tuple containing one string,
  if name is boolean False raise an assert error with message string "The name argument is not allowed to be empty.".
  call the Error function with 4 arguments, string "%s was connected to the '%s' signal with a lazy reference to the '%s' sender,
  call the DefaultStorage method, substitute the result for default_storage.
  derive class FileProxyMixin from the base class object, making it a new-style class.
  function logging.getLogger, assign the result to the security_logger.   evaluate the function force_text with e as an argument, extra is an dictionary with two pair of elements,
  value under the 'debug' key of the context_extras dictionary is boolean True.
  import pickle.
  It looks like this project was generated using Django 1.5 or earlier. You should ensure your tests are all running & behaving   as expected. See https://docs.djangoproject.com/en/dev/releases/1.6/#new-test-runner for more information.",   obj set to None and id set to a string '1_6.W001', put the result into a list and return it.   if not,
  raise an exception of class NotImplementedError with string 'subclasses of BaseCache must provide an add() method' as argument.
  if delta is smaller than integer 0,
  return response.
  if self._cull_frequency equals to integer 0.
  if exception http.Http404 as e is caught,
  import module warnings.
  call the method cursor.execute with string "DELETE FROM %s WHERE cache_key = %%s" as argument,
  break from the smallest enclosing loop.
  define the __init__ method with 6 arguments: self, name, content_type, size, charset and content_type_extra set to None.
  call the method self.validate_key with argument key.
  if value is None,
  derive the class ObjectDoesNotExist from the Exception base class.
  derive the class FileUploadHandler from the object base class.
  return size.
  define the method __enter__ with argument self.
  if weight is greater or equal to integer 6,
  LOCK_EX, LOCK_SH and LOCK_NB are all equal to integer 0.
  if e.args list first element starts with string "Error -5",
  call the pickle.dumps function with value and pickle.HIGHEST_PROTOCOL as arguments.
  define the function make_key with self class instance, key and version set to None as arguments.
  define the method url with arguments self and name.
  if ValueError or TypeError exceptions occurred,
  define the function lock with arguments f and flags.
  define the method __bool__ with argument self.
  call the __init__ method from the base class of the class ValidationError with arguments message, code and params.
  return an empty dictionary.
  val is None.
  convert timeout into an integer, return it.
  if settings.USE_TZ is true,
  define the method _get_name with argument self.
  get the name of the callback, substitute it for view_name.
  call the params.get function with string 'OPTIONS' and None as arguments, substitute the result for self._options.
  if self.LibraryValueNotFoundException exception is caught,
  raise an exception of the class ValueError with string "Key '%s' not found" as argument, '%s' is substituted for key.
  call the function CheckRegistry, substitute the result for registry.
  call the method self.set with key, value, timeout and version as arguments.
  raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a delete() method'.
  if OSError exception was raised,
  define the method temporary_file_path with argument self.
  call the mw_class function, store the result in the mw_instance.
  call the method self._delete with argument key.
  derive the UploadedFile class from the File base class.
  define the protected method _cull with self class instance, db, cursor and now as arguments.
  derive the class SkipFile from the UploadFileException base class.
  return boolean False.
  try,
  if size of c_ulong does not equals to size of c_void_p,
  define the function get_cache with backend and dictionary pair of elements kwargs as arguments.
  return default.
  _response_middleware is an empty list.
  self.model_name is a string 'cacheentry'.
  if content has an 'chunks' attribute,
  call the method self.file.close.
  define the method clear with argument self.
  call the self._createdir method.
  call the method self.make_key with key and version set to version as arguments, substitute it for key.
  tr,
  define lambda function that returns self.file.truncate field, use it as an argument for property function, put the result in truncate.
  as the arguments, substitute the result for response.   append the request to the end of the protected class member response._closable_objects.
  call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
  raise an exception StopFutureHandlers.
  from django.core import urlresolvers into default name space.
  from django.utils.http import urlquote into default name space.
  try,
  bring integer 2 to the power of 10, multiply it by integer 64, substitute the result for chunk_size.
  d is an empty dictionary.
  decorator python_2_unicode_compatible,
  set the file pointer at the beginning of the self.file file.
  convert return value of the function time.time to an integer, increment timeout by it.
  call the import_string with argument: import_path if exists or settings.DEFAULT_FILE_STORAGE, if not, return the result.
  derive the class StopFutureHandlers from the UploadFileException base class.
  derive class TemporaryFile from the base class FileProxyMixin.
  break from the endless loop.
  convert current_expires to a string, use it as the argument for the call to the function typecast_timestamp, substitute the result for current_expires.
  get property attribute _get_height, and substitute it for width.
  call the self._createdir method.
  define the method __delattr__ with self and name as arguments.
  call the method self._cache.add with key, value, self.get_backend_timeout(timeout) as arguments.
  and unpacked dictionary kwargs.   define the method new_file with arguments: self, file_name, unpacked list args and unpacked dictionary kwargs.
  self.cache_suffix converted to a string, appended to the character '*', call os.path.join with self._dir and fname as arguments,   filelist is a list containing all the previous results.   return filelist.
  library set to memcache and value_not_found_exception set to ValueError.   property decorator,
  call the function datetime.utcnow, substitute the result for now.
  derive the class ViewDoesNotExist from the Exception base class.
  if exception OSError occurred,
  obj is a string "?".
  do nothing.
  INFO is integer 20.
  import module os.
  evaluate the function backend_cls with location and params as arguments, return the result.
  try,
  finally perform,
  import module sys.
  import module logging.
  substitute params for self.params.
  if OSError, renamed to e, is caught,
  return nothing.
  define the method get with 4 arguments, self class instance, key, default set to None and version set to None.
  subtract length of the ext from the integer 255, take first elements of the name list up to the previous result index,
  define the method __iter__ with an argument self.
  derive the class CacheHandler from the object base class.
  substitute self.obj for model.
  call the method self._base_set with string 'add', key, value and timeout as arguments, return the result.
  if OSError, renamed to e, exception is caught,
  if response is None,
  use the result as an argument for the call to the function datetime.fromtimestamp, return the result.   define the method modified_time with arguments self and name.
  derive the class Error from base class CheckMessage.
  admin is a string 'admin'
  from django.utils._os import safe_join and abspathu into default name space.
  increment weight by integer 2.
  call the self._lock.writer method, with the result perform the following,
  substitute value_not_found_exception for self.LibraryValueNotFoundException.
  break from the smallest enclosing loop execution.
  try,
  try,
  from django.utils.encoding import force_bytes into default name space.
  _fields_ is a list containing 2 tuples: first tuple contains: string '_offset' and _OFFSET, second contains: string 'Pointer' and PVOID.
  do nothing
  extend the self.error_list list with message.error_list.
  call the operator.add on the values of the self object converted into a dictionary, until it is reduced to a single value, return it.
  call the method self._expire_info.clear.
  yield one element of data iterable.
  return boolean False.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  if level is not an integer raise an error with message string "The first argument should be level.".
  from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
  from django.utils.itercompat import is_iterable into default name space.
  evaluate the method self._has_expired with argument key, if it as False,
  call the method router.db_for_read with self.cache_model_class as argument, substitute the result for db.
  evaluate binary expression with 4 operands: os.O_WRONLY, binary or os.O_CREAT, binary or os.O_EXCL,
  timeout is a integer -1.
  substitute fcntl.LOCK_SH for LOCK_SH.
  define the method path with arguments self and name.
  if six.PY3 is boolean True,
  with return value of the function io.open with fname and string 'rb' as arguments, named as f,
  from django.utils.encoding import force_text and filepath_to_uri into default name space.
  if not,
  import module os.
  if e.errno equals to errno.ENOENT,
  call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
  substitute '%r' in string 'Cache key contains characters that will cause errors if used with memcached: %r' with key,
  if buffer_ is not None,
  from io import BytesIO,  StringIO and UnsupportedOperation into default name space.
  call the os.umask function with argument old_umask.
  define the method new_file with arguments: self, field_name, file_name, content_type, content_length, charset set to None,
  import stat.
  and 'request with value request, respectively use the previous as the arguments for the call to the logger.warning function.   if settings.DEBUG is True,
  call the function locks.unlock with fd as argument.
  define the method delete with arguments self and name.
  derive the class FileSystemStorage from the Storage base class.
  import module sys.
  if self.connection_reset is true,
  do nothing.
  LOCK_SH is a integer 0.
  return an empty list.
  from __future__ import unicode_literals into default name space.
  call the method pickle.dumps with value and pickle.HIGHEST_PROTOCOL as arguments, substitute it for pickled.
  LOCK_EX is a hexadecimal 2.
  append check.tags into a list for every check in self.registered_checks if check has 'tags' attribute, put the elements into a set and return it.
  if self has an attribute '_size'.
  try,
  for every middleware_method in self._view_middleware,
  define the method __nonzero__ with argument self.
  define the method add with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  if self._dir file path does not exists,
  define the method __init__ with arguments self, content and name defaulting to None.
  call the os.path.splitex with argument name, assign the result to name and ext, respectively.
  call the translation.get_language_bidi function, substitute the result for the value under the 'LANGUAGE_BIDI' key of the context_extras dictionary.
  define the method accessed_time with arguments self and name.
  if ImportError exception is caught,
  do nothing.
  substitute base_url for self.base_url.
  substitute content_type for self.content_type.
  return string 'StopUpload: Halt current upload.'.
  from django.utils.text import get_valid_filename into default name space.
  if KeyError exception is caught,
  define the function check_1_7_compatibility with argument kwargs dictionary.
  self.content_type_extra is None.
  from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
  if call to the settings.is_overridden with string 'TEST_RUNNER' evaluates to boolean False.
  and param_dict, respectively.   evaluate the function callback with request and dictionary of parameters param_dict as the arguments, return the result.
  call the function datetime.fromtimestamp with argument timeout, substitute it for exp.
  substitute length of content for self.size.
  size, charset, content_type_extra.   substitute field_name for self.field_name.
  call the method self._cache.clear.
  if not,
  do nothing.
  define delete method with self class instance, key and version set to None, as arguments.
  call the method self.validate_key with argument key.
  evaluate debug.technical_500_response with request and list of arguments exec_info, return the result.
  define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
  call the function settings.is_overridden with argument string 'MIDDLEWARE_CLASSES', if the result is boolean False,
  define the method _cull with argument self.
  call the method self._get_size_from_underlying_file, substitute the result for self._size.
  call the params.get with string 'OPTIONS' and empty dictionary as arguments, substitute the result for options.
  do nothing.
  define the function close_caches with dictionary pair of elements kwargs as argument.
  derive the InMemoryUploadedFile class from the UploadedFile base class.
  self.content_length is None.
  for every cache in return value of the function caches.all.
  define lambda function that returns self.file.isatty field, use it as an argument for property function, put the result in isatty.
  call the os.path.getsize function with argument self.file.name, return the result.
  TEMPLATE_FRAGMENT_KEY_TEMPLATE is a string 'template.cache.%s.%s'.
  if e.errno does not equals to errno.ENOENT,
  self.content_type is None.
  if file object has an attribute 'mode',
  try,
  import module codecs.
   if self.file_permissions_mode is not None,
  call the method self.make_key with key and version set to version as arguments, substitute it for key.
  settings.BASE_DIR.
  if not,
  raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a set() method' as argument.
  return boolean True if self.level is greater than or equals to ERROR, otherwise return boolean False.
  from django.utils import six into default name space.
  define initialization method __init__ with self class instance, unpacked list args, unpacked dictionary kwargs as arguments.
  define the method delete with self class instance, key and version defaulting to None as arguments.
  define the function check_all_models with app_configs defaulting to None and unpacked dictionary kwargs as arguments.
  define the method close with self class instance as the argument.
  import pickle.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  return name.
  define the method delete_many with 3 arguments: self, keys, and version set to None.
  response_fixes is a list with  http.fix_location_header and http.conditional_content_removal as elements.
  call the os.path.normpath with argument path, return the result.
  p is image parser object, set by calling the PillowImageFile.Parser method.
  call the os.utime function with arguments dst and tuple containing 2 elements: st.st_atime and st.st_mtime.
  if ImportError or AttributeError exception occurred,
  from django.utils import timezone and six into default name space.
  define the method delete_many with arguments self, keys and version defaulting to None.
  return string 'StopUpload: Consume request data, then halt.'.
  self._cull_frequency is integer 3.
  call the resolver.resolve_error_handler with integer 500 as the argument, assign the resulting tuple elements to the callback,
  if base_url is None,
  call the method router.db_for_write with argument self.cache_model_class, substitute the result for db.
  substitute '%s' in TEMPLATE_FRAGMENT_KEY_TEMPLATE string with fragment_name and args.hexdigest(), respectively, return the result.
  try,
  if last element of line is newline or carriage return character,
  call the file.__exit__ method on self with exc, value and tb as the arguments.
  for every entry in os.listdir function return value called with the argument path,
  current_chunk is None.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  derive the SimpleUploadedFile class from the InMemoryUploadedFile base class.
  if fname doesnt start with self._dir and fname file path doesnt exists,
  if self equals to other return boolean False, otherwise return True.
  remove 'LOCATION' key from kwargs dictionary and put it into location, or use an empty string if key doesnt exists.
  define the method register with self ans unpacked list tags as arguments.
  derive the class SuspiciousFileOperation from the SuspiciousOperation base class.
  return boolean False.
  if attribute '_client' of the self object is None,
  return self.size.
  try,
  read the whole self file and yield it as a generator return value.
  define the method get with 5 arguments, self class instance, key, default set to None and version set to None.
  docsring
  "Django 1.7 changed the global defaults for the MIDDLEWARE_CLASSES. django.contrib.sessions.middleware.SessionMiddleware,   django.contrib.auth.middleware.AuthenticationMiddleware, and django.contrib.messages.middleware.MessageMiddleware were removed   from the defaults. If your project needs these middleware then you should configure this setting.", obj set to None, and   id set to a string '1_7.W001', put the result into a list and return it.   if not,
  if self.id is contained in settings.SILENCED_SYSTEM_CHECKS return boolean True, False otherwise.
  call the method self.handle_uncaught_exception with request, resolver and return value of the function sys.exec_info as the arguments.
  open file named file_or_path for reading, store the file object handle in file.
  call the method signals.got_request_exception.send with sender set to type of the self class instance and request set to request.
  if os.path.exists function with argument name, evaluates to boolean True,
   self._template_response_middleware is an empty list.
  define the method delete with arguments self and name.
  call the function _check_middleware_classes with dictionary kwargs as argument, use the result as an argument for the call to the function errors.extend.
  if exception SuspiciousOperation as e is caught,
  define the function request with an argument request.
  if name is None,
  from django.views import debug into default name space.
  raise an ValueError with string "This file is not accessible via a URL." as argument.
  divide num_entries by self._cull_frequency, convert the result to an integer, call the random.sample function with filelist and previous result as arguments, substitute the result for filelist.
  call the self._lock.writer method, with the result perform the following,
  try,
  return boolean False.
  do nothing.
  append character '/' to the base_url.
  and expires is not an instance of datetime.   convert expires to a string, use it as argument for the call to the function typecast_timestamp, substitute the result for expires.
  from django.conf import settings into default name space.
  if pickle.PickleError exception is caught,
  import module errno.
  do nothing.
  import module os.
  call the method cursor.execute with string "DELETE FROM %s WHERE cache_key = %%s" as argument,
  if allow_overwrite is boolean False and call to the os.access function with arguments new_file_name and os.F_OK evaluates to boolean True,
  if not,
  buffer_ is None.
  call the options.get method with string 'MAX_ENTRIES' and integer 300 as arguments, use the string 'max_entries' and previous result as the arguments for the call to the params.get method, substitute the result for max_entries.
  define the method __bool__ with argument self.
  evaluate the method connections[db].ops.cache_key_culling_sql, evaluate the result by table modulus, call the method cursor.execute,
  call the method self._save with arguments name and content, substitute it for name.
  define the method get with 5 arguments, self class instance, key, default set to None and version set to None.
  settings.SITE_ID.
  num_entries is length of filelist.
  if self._dir path doesnt exists,
  from django.db import models into default name space.
  call the method self._is_expired with argument f, invert the boolean result and return it.
  call the method self.make_key Whit key and version set to version as arguments, substitute the result for key.
  call the ops.quote_name method with argument self._table on the value under the db key of connections dictionary, substitute the result for table.
  if ret is true.
  append mw_instance.process_view at the end of self._view_middleware.
  if file_or_path has an attribute 'read',
  return self.file.name.
  if ImportError exception is caught,
  convert cull_frequency into an integer and substitute it for self._cull_frequency.
  substitute the second element of result for current_expires.
  divide num by self._cull_frequency, floor the result and substitute it for cull_num.
  define method _get_height with self class instance as the argument.
  replace tags for check.tags.
  substitute '%s' in string 'Cache key will cause errors if used with memcached: %s (longer than %s)' with key,
  substitute '%s' in string '<%s: %s>' with self.__class__.__name__ and self, if exists, or string 'None' if it doesnt, return it.
  call the OVERLAPPED function, substitute the result for overlapped.
  call the self.seek method with argument integer 0.
  call the function import_string with argument backend.
  define the _fd function with argument f.
  substitute the datetime.max for exp.
  evaluate the self.has_key method with key as argument, return the result.
  use the result as an argument for the call to the function datetime.fromtimestamp, return the result.   define the function get_storage_class with argument import_path=None defaulting to None.
  substitute charset for self.charset.
  raise an exception.
  for every field, error_list in self.error_dict.items method return value,
  define lambda function that returns self.file.encoding field, use it as an argument for property function, put the result in encoding.
  raise an exception of class NotImplementedError, with string 'subclasses of BaseCache must provide a get() method' as argument.
  call the os.makedirs function with directory and self.directory_permissions_mode as arguments.
  from ctypes.wintypes import BOOL, DWORD and HANDLE into default name space.
  derive the class SuspiciousOperation from the Exception base class.
  call the method tempfile.NamedTemporaryFile with argument suffix set to string '.upload'.
  if zlib.error as e exception is raised,
  if not,
  define the method accessed_time with arguments self and name.
  define method __exit__ with self, exc, value and tb as the arguments.
  substitute content_type_extra for self.content_type_extra.
  new_value is a sum of value and delta.
  evaluate self._is_expired method with f as argument, if the result is false,
  return client.
  otherwise if base_url does not ends with '/' character,
  define the function unlock with argument f.
  from django import http into default name space.
  if not,
  from django.utils.module_loading import import_string into default name space.
  close file file.
  derive the class BaseMemcachedCacheMethods from RenameMethodsBase the base class.
  get models.signals name attribute, store it in obj.
  call the function locks.lock with fd and locks.LOCK_EX as arguments.
  derive the class _OFFSET from the Structure base class.
  return check.
  call the method self.registered_checks.append with argument check.
  weight is an integer 0.
  substitute result of the self.path function with argument name for full_path.
  from django.core import signals into default name space.
  raise an AttributeError exception with string "Unable to determine the file's size." as argument.
  call the method cls with 3 arguments: value under the 'filename' key of file_dict, value under the 'content' key of file_dict,
  substitute connection.queries for value under the 'debug' key of the context_extras dictionary.
  from django.utils.six.moves import cPickle as pickle into default name space.
  do nothing.
  if response is None,
  return boolean False.
  if six.PY3 is true,
  define the __init__ method with argument self.
  derive the class FileBasedCache from BaseCache base class.
  call the __init__ method with 3 arguments: DEBUG, unpacked list args and unpacked dictionary kwargs from the base class of Debug.
  ERROR is integer 40.
  call the function self._key_to_file with key and version as arguments, substitute it for fname.
  substitute message.error_list for message.
  call the method self.validate_key with argument key.
  call the self._lock.writer method, with the result perform the following,
  derive the class DefaultStorage from the LazyObject base class.
  substitute content_type_extra for self.content_type_extra.
  return default.
  define the method incr with self class instance, key, delta set to integer 1 and version set to None, as arguments.
  define the method __init__ with 7 arguments: self, file set to None, name set to None, content_type set to None, size set to None, charset set to None and content_type_extra set to None.
  define the method open with arguments self, name and mode defaulting to string 'rb'.
  from django.utils import translation into default name space.
  define the method __setattr__ with self, name and value as arguments.
  return self.file.closed.
  errors is an empty list.
  substitute '%s' in 'django.security.%s' with the name of the type of the class object e, use it as the argument for the call to the,
  call the method self.file.write with argument raw_data.
  with call to the io.open function with fname and string 'rb' as arguments, renamed to f,
  from django import http into default name space.
  if server is an instance of six.string_types,
  do nothing.
  request_middleware is an empty list.
  substitute library for self._lib.
  for every field, messages in return value of the message.items method,
  substitute resolver_match for request.resolver_match.
  if features.needs_datetime_string_cast field of the object represented stored under the db key of connections dictionary is true,
  define the method message_dict with an argument self.
  call the function os.path.basename with argument name, substitute the result for name.
  call method __init__ from the base class of the class PyLibMCCache with arguments: server, params,
  substitute fcntl.LOCK_EX for LOCK_EX.
  return nothing.
  return errors.
  double the chunk size.
  decorator register with Tags.models and Tags.signals as arguments.
  call the method cursor.execute with string "SELECT cache_key, value, expires FROM %s WHERE cache_key = %%s" as argument,
  return value under the alias key of self._caches.caches dictionary.
  define initialization method __init__ with 4 arguments: self, host, list of arguments args and dictionary of arguments kwargs.
  import pickle.
  raise an NotImplementedError exception with argument string 'subclasses of Storage must provide a size() method'.
  define the method clear with argument self.
  try,
  call the __init__ method with 3 arguments: INFO, unpacked list args and unpacked dictionary kwargs from the base class of Info.
  if mw_instance has an attribute named 'process_response'.
  import module time.
  from django.apps import apps into default name space.
  evaluate the function BytesIO with argument chunk, substitute it for chunk_buffer.
  from django.db import connections, transaction, router and DatabaseError into default name space.
  do nothing.
  call the function params.update with argument kwargs.
  define the method new_file with arguments: self, unpacked list args and unpacked dictionary kwargs.
  call the self.make_key with key and version set to version as arguments, substitute the result for key.
  define the method add with 5 arguments, self, key, value, timeout defaulting to DEFAULT_TIMEOUT and version defaulting to None.
  convert self to a list and return it.
  raise the exception.
  call the function warnings.warn with string "'get_cache' is deprecated in favor of 'caches'.", RemovedInDjango19Warning,
  call the import_string with argument backend, substitute it for backend_cls.
  get attribute name from value under the DEFAULT_CACHE_ALIAS key of caches dictionary, return it.
  from datetime import datetime into default name space.
  define the method set with 5 arguments, self class instance, key, value, timeout set to DEFAULT_TIMEOUT and version set to None.
  raise an SuspiciousFileOperation exception with string "Attempted access to '%s' denied." as argument, replace '%s' with name.
  get the position in bytes from the start of the file, store it in file_pos.
  try,
  call the method self.get_available_name with argument name, substitute it for name.
  from django.core.files.move import file_move_safe into default name space.
  self._view_middleware is an empty list.
  from django.core.cache.backends.base import BaseCache and DEFAULT_TIMEOUT into default name space.
  define the messages with an argument self.
  define the initialization method __init__ with arguments: self class instance, dir and params.
  define the initialization method __init__ with 3 arguments: self, name and params.
  call os.makedirs function with self._dir and hexadecimal 0o700 as arguments.
  raise an exception.
  substitute self.DEFAULT_CHUNK_SIZE for chunk_size.
  with name of the class type of the middleware_method instance, use it as the argument for call to the ValueError exception raise.   call the response.render() method and assign the return to the response.
  return raw_data.
  for every key and value in data.items function return value,
  define iterator method __iter__ with self as the argument.
  define the method incr with self, key, delta defaulting to integer 1 and version defaulting to None as arguments.
  binary or 'O_BINARY' attribute of the os object, or integer 0 if it doesnt exists.   call the os.open function with full_path, flags and octal number 0o666 as arguments, substitute the result for fd.
  evaluate self._has_expired with argument key, if the result is True,
  if response is None,
  self.activated is boolean True.
  call the method self.make_key with key and version set to version as arguments, substitute the result for key.
  substitute file.mode for self.mode.
  import module django.core.checks.compatibility.django_1_7_0.
  from django.core.files import locks into default name space.
  if num is greater than self._max_entries,
  from django.conf import settings into default name space.
  call the cursor method on the value under the db key of connections dictionary, preform following with return value named cursor,
  append mw_instance.process_request at the end of request_middleware.
  if not,
  if ret equals to integer 0, return boolean True, otherwise return boolean False.
  define lambda function that returns self.file.write field, use it as an argument for property function, put the result in write.
  from django.conf import settings into default name space.
  define the method det_valid_name with arguments self and name.
  call the os.path.splitext with argument file_name, assign the result to the file_root and file_ext respectively.
  if buffer_ is true,
  import module random.
  substitute list containing element self for self.error_list.
  define the method __str__ with argument self.
  define initialization method __init__ with argument self.
  derive the class PermissionDenied from the Exception base class.
  if fname file path exists,
  from __future__ import unicode_literals into default name space.
  define the method _get_closed with argument self.
  define the method handle_raw_input with arguments: self, input_data, META, content_length, boundary and encoding set to None.
  if SystemExit exception is caught,
  from django.conf import settings into default name space.
  delete the value under the key key of self._cache dictionary.
  call the self._delete method with argument fname.
  remove 'LOCATION' key from kwargs dictionary and put it into location, or use an empty string if key doesnt exists.
  call the ops.quote_name method with argument self._table on the object under the db key of connections dictionary, substitute the result for table.
  return boolean True.
